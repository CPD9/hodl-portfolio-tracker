# Web 3.0 Cryptocurrency Exchange Decentralized Application Tutorial

**Source:** `Build and Deploy a Web 3.0 Cryptocurrency Exchange Decentralized Application.mp4`

**Duration:** 3:15:31

---

## Table of Contents

- [00:00:00 - Intro](#000000---intro)
- [00:06:34 - Cranq Setup](#00634---cranq-setup)
- [00:12:30 - MetaMask Setup](#01230---metamask-setup)
- [00:15:05 - Alchemy Setup](#01505---alchemy-setup)
- [00:20:03 - Cranq Part One - Factory](#02003---cranq-part-one---factory)
- [00:30:58 - Cranq Part Two - Router](#03058---cranq-part-two---router)
- [00:44:55 - Cranq Part Three - Liquidity](#04455---cranq-part-three---liquidity)
- [00:54:49 - Create Your ERC20 Tokens](#05449---create-your-erc20-tokens)
- [01:10:39 - Frontend Setup](#11039---frontend-setup)
- [01:19:54 - Layout](#11954---layout)
- [01:41:54 - Web3 Logic](#14154---web3-logic)
- [02:08:41 - Exchange, Inputs, and Balance](#20841---exchange-inputs-and-balance)
- [03:15:31 - Deployment](#31531---deployment)

---

## 00:00:00 - Intro

Hi there, and welcome to a project video where you'll build and deploy a modern Web3 decentralized application with a stunning design, Metamask pairing, live smart contract data fetching, and most importantly, the ability to create your own ERC20 tokens and much more. Uniswap is the best Web3 app that you can currently find on YouTube. This is the perfect video to fully understand how Web3 smart contracts and Uniswap work behind the scenes. By building this single Web application with me, you can finally wrap your head around Web3 and smart contracts. There are many tutorials that are hard to understand. They jump between many technologies and are almost impossible to follow. Today, you'll learn how to develop a professional and a fully functional Uniswap clone using the most-in-demand technologies today and also deploy to the internet so that you can share it with your friends, employers, and put it on your portfolio. You might be wondering, what are the prerequisites for building such a fantastic Web site? Besides a little react knowledge needed, this course is entirely beginner-friendly. We're going to start simple and then move to more complex topics as we go. I'll explain every step of the way, from creating the folder on your desktop all the way to deploying the smart contracts as well as the application itself to the internet. Alongside building this phenomenal application, you'll also learn react functional components and their reusability, react file and folder structure. We'll use custom hooks and utility functions to manage the state of our application. You'll learn to create, compile, and deploy your own smart contracts to the blockchain. You'll achieve mastery using Tailwind and make the app responsive on all devices. And most importantly, you'll learn how to use Crank. Crank is a graphical and intuitive IDE that allows us to compile and deploy our smart contracts. In my opinion, this is the best way to truly understand how Web 3 and smart contracts work. It has a graphical interface where you can visually track how the code is being executed by looking at its flow. That's incredibly useful as if you think about it, you never really see the flow of your code in your regular code editor. Therefore, Crank makes it incredibly simple to understand how smart contracts truly work behind the scenes. Crank is new and it has the potential to become a faster way of coding. It also makes it easier to understand other people's code. You're going to see that today in action because we're going to build on top of the original Uniswap's codebase. If this video reaches 20,000 likes, I'm recording another Web 3 decentralized application video, so smash that like button. With that said, let me give you a quick demo of how our Uniswap 2.0 works. You'll be greeted with this beautiful screen that asks you to connect to your wallet. So let's do just that. After clicking the Connect wallet button, a wild metamass notification appears. We can click next and then connect. As soon as we are connected, we can immediately start swapping tokens. Now, there's a couple of things happening here. First of all, we have JSM Gold and JSM Silver tokens. How cool is that? You'll be able to create your own ERC20 tokens on the Ethereum network. Another cool thing is that we are live fetching the data from the blockchain. If we try to convert 100 Gold to, let's do Silver, you can notice that both balances change. But more importantly, the actual amount of JSM Silver will be getting after the swap is live fetched from the blockchain and displayed right here. It works just like the real Uniswap. Now, usually, a swap is a two-step process. So first, we have to approve the swap. But since I've done before, now we are just ready to immediately swap it. So let's click the swap button. A new metamass notification appears, and we can click confirm. This process usually takes just a couple of seconds. And there we go. Once it is done, we can see swap executed successfully and the balances changed. And this application is also fully mobile responsive. It works perfectly on all mobile devices, as well as tablets, and of course, desktop. What I've just showed you might seem simple, but trust me, there's a lot of blockchain and web3 logic happening behind the scenes. And they strongly believe that building this app is the best way to truly understand how web3 and smart contracts work. Excellent. With that said, there's just one more important announcement I want to share with you before we dive into the project. Since this is a Web3 Heavy project-based video, I've also prepared for you two entirely free Web3 resources. One is a comprehensive Web3 roadmap, and the other is a solidity cheat sheet. The link to download these resources entirely for free is in the description. On top of that, I've also created a Web3.0 course in which you'll build an entire fully functional NFT marketplace. This 10-hour course dives into everything you need to know about solidity, Web3, and smart contracts. Also, since you're watching this video, by using the link in the description, you're going to get a special discount code that's going to automatically be applied for you during checkout. This groundbreaking project will impress your potential employers, making gsmastery.pro, the only source of knowledge needed to land y

---

## 00:06:34 - Cranq Setup

our dream high-paying Web3 job that you can enjoy for many years to come. With that said, let's dive right into today's video. To start building our own version of Uniswap, believe it or not, we're going to build it on top of Uniswap's original source code. We'll be using the Uniswap V2 core, as well as the Uniswap V2 periphery to build it. Each one of these repositories has three smart contracts, and every one of these smart contracts has a lot of code. But here's the thing, we won't have to modify these smart contracts directly, as that would be quite hard without having immense skill in solidity development. Instead, Crank will abstract the most critical functionalities from these smart contracts and allow us to build on top of them. To download Crank, click the link down in the description, you'll be greeted with their website, and then you can simply click the download button to download it for your own operating system. That process is going to take just a minute, so I'll see you right inside of Crank. Once you load up Crank and open up your first empty project, you'll be greeted with a screen that looks something like this. To get started, let's go ahead and rename our project to something like Warchspace, Uniswap underscore clone. Great. Now, let me provide you a really quick intro to some basic Crank functionalities. The two circles that you can see on your screen right now are called nodes. Every node can have an output as this one has right there, and they can also have inputs. Crank also has a huge library with hundreds of different nodes that you can access simply by clicking this plus icon on top left. It's going to open up, and as you can see, there's nodes for absolutely everything. There are nodes to sync some kind of data, to split it, to repeat it, anything you can think of, it's going to be there. We even have some simple, logger nodes. You're going to learn how to use a lot of these throughout this video. Now, we were talking about those smart contracts from Uniswap. So, let's search for Uniswap. As you can see, there are a lot of nodes, which directly correspond to that. Now, in this case, we first want to compile a smart contract, so let's add Uniswap compile to the search. There, you can see a factory compiler and a router compiler. Let's go ahead and drag and drop those nodes right here. Then, we'll want to deploy these contracts. So, let's search for Uniswap deploy, and luckily, there is a factory deployer, which we're going to put right here next to the factory compiler, and there is the router deployer, which we can put right here. Now, let's make some room between the start and the end, so we have a lot of space to work with. Now, it's simple to see that we have two different pairs of nodes. We have the factory compiler right here, and also the factory deployer, and we also have the router compiler and the router deployer. Now, you can hover over the factory compiler and drag its compiled factory contract over to the factory contract of the factory deployer. There we go. So, simply drag and drop it. You can also repeat the process for our factory compiler and factory deployer. Every node in crank needs at least one input or one signal to start working. In this case, the starting signal will be the whole start of our contract compile and deployment process, which is the green node on the left side. So, simply drag the start to the input signal of the factory compiler. On the other hand, a factory deployer can have a couple of inputs. It has a fee-setter address, which is optional, and it also has a config. To create the config, we can create a crank store. So, let's simply search for store, and what it can do is explain right here. Stores data and sends it via the data when read. So, simply put, crank store saves variables and any other data. Now, we can click on the data part of the store, and in here we can enter some values. But the question is, how can we know what has to go into this config right here? Well, let's click it, and here is one great thing that crank provides. It's highly focused on types. In here, we can see the type of the config object, so we know exactly what we have to pass. Let's go ahead and copy it, go back to the data part of the store, and paste it there. Now, there's going to be one more thing we can add to it, and that is going to be network. We'll be working with an Ethereum test net called GERLY. So, let's type it out right here, and now let's replace those strings to simply empty strings, which we'll be able to populate soon enough with real data. And since this is JSON, we have to remove the last comma. There we go. So, now we have our store, but the question is, where are we going to get the data needed for this config object? As we always do in JavaScript mastery, I'm going to teach you how to

---

## 00:12:30 - MetaMask Setup

get all of the values required to properly compile and deploy a smart contract. So, let's start with that right away. First, we have to get Metamask. Metamask is the most popular crypto wallet out there, and if you want to work in Web 3 space, you'll need it sooner or later. So, in case you don't have it already, you can simply click download for your browser. That's going to bring you to the store of your browser, and then simply click add. In just a couple of seconds, you'll be redirected to this page with this cute fox, and you can also pin the extension to the top right of your browser. Now, let's get start with setting up Metamask. To get started, we have to agree, and then we have to create a new wallet. You have to choose a secure password, eight characters minimum, and agree to the terms. Now, this is a really important part, and I will suggest you to watch this two-minute video teaching you how to properly store your secret recovery phrase. When working with Web 3 cryptocurrencies and wallets, the secret recovery phrase is the master key. It is the most important thing there is, not your password, so make sure to properly store it somewhere safe. Now, let's click next. In here, you'll be given a series of words. You have to reveal them, and then copy them in some kind of a notepad, or on a paper using a pen. Once you do that, you can enter them one by one right here. In my case, it was sued. We also had Jim there and so on. Of course, you need to do this on your end for your own words. Congratulations! Now, you have your own crypto wallet. We can see that we are right now on the Ethereum mainnet. You want to click that part on top right, and then click show and hide test networks. That's going to bring you to the settings and make sure to toggle it on. Now, let's go back and let's switch it to the early test network. This is crucial. Once you do that, you'll see your own Ethereum wallet right in your Metamask and will be able to use this soon enough. And immediately, we can copy the address right here to clipboard, go back to crank, and simply paste it right here u

---

## 00:15:05 - Alchemy Setup

nder account address. Now, for these two other values, we'll have to use another great website. And that website is called alchemy. Alchemy is a web3 development platform. We're going to compile and deploy all of our smart contracts using crank, but alchemy is going to allow us to actually deploy them to the blockchain. So, you can either click login or click get started for free. You can then sign up using Google or enter your information below. Since I already had an account, it brought me straight to my dashboard. If you're creating a new account, it's going to ask you a series of questions. Simply click next to most of them, select Ethereum as your blockchain, and then at the end, when it asks you how did you hear about us, feel free to put JavaScript mastery in there. You can choose a free version. There is going to be a prompt to enter payment details, but you can select skip for now. So, this process is entirely free, which is great. And then at the end, when it asks you how did you hear about us, feel free to put JavaScript mastery there. With that said, once you're done with that form, you'll be redirected to your own dashboard. There, you'll be able to see a demo application, as well as the JavaScript mastery or your name app right there. But what we want to do is to create a new app. The name of her app can be Uniswap clone. Now, we're going to be on the Ethereum chain, but the network is going to be girly. There is also a wrinkled by test network, but you can see it's getting deprecated. And on JavaScript mastery, we always teach you how to use the latest and the most in demand technologies. So, let's go for girly. And with that said, we recently released a huge Web3 course teaching you how to build your own NFT marketplace to master solidity, smart contracts, blockchain development, next GS, and much more. So, if you like the video you're watching right now, and if you'd want to build your own full stack NFT marketplace, where you can explore different NFTs, see your NFTs and create NFTs, then this is the course for you. Just by watching this video, you're immediately getting a big discount, the link is going to be down in the description. With that said, let's go back to Alchemy and let's create our great application. It's going to be created instantaneously and we can immediately click View key. There, we have the API key, as well as our HTTPS address. So, let's copy one by one, starting with the API key. We can paste it right here under Private key. And one more time returning to Alchemy, we can copy the HTTPS address. And we can paste it right here under the provider URL. Now, you might already know that this right here is private information, private keys, account addresses, and provider URLs, which all contain your data. It's usually not advisable to simply put it in an object and store it right there. We will use this method for development purposes to speed things up, but the recommended approach, of course, is to store this data in environment variables. And in Crank, it is incredibly simple, simply search for environment. And you can see a node that says environment variables get her with fullback. So, it is incredibly simple to get a lot of the variables from your file system, where it is entirely safe. And this was a cool thing we just explored about Crank. Whatever you need, you can simply search the node library for it. And you'll immediately get the nodes that are going to help you with whatever you're doing. Great. With that said, we can now quickly get back to our browser, more specifically, to our Metamask account. If you close this page, no worries, you can simply click the Metamask extension. And there also, you can copy your account address. Once you copy it, you can go to girlyfosset.com. The link is also going to be down in the description. This right here is a Fosset. A Fosset fills up your test girly Ethereum. And we'll need some test Ethereum to compile and deploy our smart contracts. So, make sure you're logged in with Alchemy, and then simpl

---

## 00:20:03 - Cranq Part One - Factory

y paste your wallet address and click send me some Ethereum. Great. So, this will almost immediately send you your Ethereum, and you'll be able to see it right there. And there we go. I got it immediately. Sometimes this does take a bit more time, but no worries, because we have more important things to do. And those things are, of course, back in crank. So, by the time while we finish creating the compilation and deployment of these smart contracts, we'll have our Ethereum, so no worries there. Great. So, now that we have our store, we can drag it right there, and we can connect the data part of that store to config of the factory deployer. Great. Now, when it comes to the outputs of the factory deployer, we have events, error, and confirmation. Let's look at what events say. Let's click it. And as you can see, multi-plexed events. Interesting. And we can see the type there. I don't really know what that is. So, whether we learn, we just use the node library. Let's go ahead and search for multi-plexed or just multi-plexed events. And we can see a multi-plexed event logger. That seems like a good candidate. So, let's simply put it here, and let's connect it. For the error, let's search for a logger node. And we want the logger with message. So, let's also drag and drop it. And we can connect the error to the data part of that node. And when it comes to the message, we can click it. And add the value. That can be something simple like factory deployment, compilation error. There we go. And finally, we don't yet know what we'll get as the confirmation from the factory deployer. So, let's simply log it out. We already have one log node right here on the right side of our screen. So, let's just bring it here. And let's connect the confirmation to it. Now, it's getting a bit crowded over here. So, we can group related nodes by holding shift, and then clicking on the factory compiler and factory deployer. Then, right click and click group nodes. Now, we can go to the instance of that group. And then we can rename it to something like compile and deploy factory. Great. And we can do the same thing for our router compiler and router deployer. So, let's simply hold shift, click them, right click, group nodes. And let's call this, that's going to be compile and deploy router. There we go. Now, we have a bit of a cleaner working environment. We can also rename the store to something more meaningful. So, click it, go to its instance, and let's call it config. And as we said, every node needs a static signal. And that's the same for config as well. So, we can connect the start to the read part of the config. There we go. So, now we have the start to config, and that config is getting into decompile and deploy factory, which is now a node group. We've done a lot of work. And finally, it's time to see the output. So, let's click the play icon on the top right of the screen to start it. You can also use a shortcut, control, or command, or. And believe it or not, crank is now installing MPM dependencies behind the scenes. So, let's give it a moment. Once the project starts running, you can see these green lines showing you how our code is being executed. As you can see, almost everything turned green besides our compile and deploy factory. It's red, so it means that we have an error there. So, if something goes wrong, how would you debug things in crank? Well, the debugging process is genuinely fun and satisfying to do in crank, through a graphical user interface. We can literally see how our code is being executed, which is never the case in just plain code. So, how you debug things in crank is you dive deeper into your components to figure out what's happening. So, let's double click the compile and deploy factory. You can see everything works, but there's an error there. So, if you hover over it, it says error during execution inside. Please drill in for details. So, one more time, let's go inside of it. And the right here, we have the deploy factory contract. If we hover, it says again, drill down for details. And in here, we have a node that is red. And if you hover over it, it says private key must be 32 bytes long. Great. So, that gave us a lot of info. Something is wrong with our private key. And also, while doing this, you'll learn how to debug things in crank, how simple it is, but also how to dive deeper into components. Now, if you want to go back, you simply use these breadcrumbs at the top of the screen. And you can see how everything is being abstracted away. That's exactly what I meant at the start of the video when I said that we won't have to literally create or write or add to that Uniswap smart contract. Great. Let's go back. And now, we can look into our config, go to the data, and notice right here that I provided the wrong private key. This here should be 32 bytes. And the key that we should have provided was the one from the Metamask account. So, open up your extension, click those three dots right there, and then go to account details. There, you can see export private key. Click that, you'll have to enter your Metamask password. And you're going to get your private key. And of course, never disclose this to anybody. So, let's copy it. And let's paste it right there for our private key. Great. So, now we know that everything is right. And I'm not going to really have any real funds in this account. So, I'm showing this on video. But of course, if you're working with some real cryptocurrencies, never ever show your private key to anyone. Now, as I mentioned, the shortcut to rerun the application is control or command R or simply press the play icon on top right. You can see it's being executed, project running, and the green line went all over to the event logger, which means that our code so far works. The output window that you can see on the bottom left of your screen is quite useful. We can check what's happening here. We get the transaction hash, and then we also get the number of confirmations. But even more important than that is that we can right-click any connection, for example, this one, and we can see the traffic. So, right-click, show traffic, and there we go. You can see exactly what data is flowing to this logger right there. Isn't that crazy. So, again, this is quite useful when you're debugging as well. In this case, we just wanted to see what is being passed to our log, but we don't really have to use it. So, we can right-click it, and disable this node. We can also see what we're getting to this log down there by showing the traffic, and you can see it's counting some kind of confirmations. What is really cool is that what you can see right there on the bottom left of your screen inside of the output is the real message coming from the blockchain after our factory contract has been deployed. Before we can say for sure that our deployment succeeded, we need to wait for 24 confirmations. Right now, we are just at 7. That is a long time, but we already have the contract address that we can check on EtherScan. You can copy this transaction hash right there, and then you can go to girly.etherscan.io, or you can click the link in the description as well, and then paste that transaction hash and search for it. Again, make sure that you are on the girly.etherscan.io. You can see a successful status. If you head to the from address, you can see that we have a successful content creation. We just deployed a smart contract in a couple of minutes without writing a single line of code. I think you can already see how powerful krank is, but we are just getting started. On the top left of the screen, you can click activity, and then we can get back to editing mode. And we can also close the output. Now we are getting back to the editing part. You can now double click on our compile and deploy factory to open it up. Click the plus icon on the top left, and search for contract, deployment, waiter. We need to wait for the confirmation to finish, so this will come in handy. So let's simply take it and then put it right here below. We can see that it is expecting a confirmation, which we already have. So simply drag and drop it from the factory deployer. And it also expects a number required. So click it. Usually it is set to 24 by default, but for development purposes to make it a bit quicker. Let's switch it to 2 for now. Now instead of sending the confirmation from the previous node as we have been doing so far, let's delete that connection, rename the confirmation output to contract address, change the data type to string, and then connect the output from the contract address to this input right there. Perfect. So now it's actually waiting for the confirmation to finish, and then it's sending the address of the deployed smart contract. Isn't that cool? To go a level up, back to the workspace, simply use the breadcrumbs on top of the scr

---

## 00:30:58 - Cranq Part Two - Router

een. Now let's pull our config a bit down, and let's also pull the event and the error to the top of the screen right here, because they're not that important for now. We saw what's coming through, and we can also delete the longer node by right clicking it and then clicking delete. Great. So now notice how we are going from left to right, we have the config, we're doing the compile and deploy factory, and now we're going to keep going to the right side as our code executes. And now we can continue with the second step, which is working with the compile and deploy router. You can go into it by double clicking. Let's start again from left to right. We can see that our router compiler takes in a factory init hash as its input. In the sidebar, let's search for init code hash, and then drag and drop the node right here. Connect its output to the router compiler's input, and let's move this a bit to the right. Now looking at the router deployer, it needs a factory address, WETH, which is short for wrapped ethereum, it needs a config, and it needs the router contract. We already know the factory address will come from the first step, so we can create a new input on our node group called factory address. So right here it's currently in, but name it factory address, and it's going to be of a type string. We can also add a couple more inputs. The first one being the factory ABI, so that's going to be factory ABI, and finally we're going to pass in the config right here as well. These are all the parameters that will be passing to this group. Now let's connect the factory address and the ABI to the init code pair, because it's expecting them. So that's going to be the factory address, and also the factory ABI. Now where are we going to get the web3 provider URL from? Well, if you think about it, our config is an object that contains many properties. For now, we just need one, the provider URL. So to retrieve it, let's search for an item getter property, or rather a node. There we go, item getter. It says that this node retrieves an item from the specified index, but we want to get this one, not retrieving by index, but rather retrieving by its key. So let's drag and drop it, and then it's accepting a dictionary, which is simply an object. So let's pass the config as the dictionary, and as the key, we can pass a string of provider URL. There we go. We can rename that item getter to get provider URL, and we can connect its output value to the final remaining input in the init code pair hash requester. So value into that right there. There we go. So it's getting a bit complicated, but it's easy to follow along if you just follow the inputs and follow everything from left to right, the way we're passing things. We're just making sure that older required inputs have something in them. So let's expand everything by dragging it a bit more to the right, just to give ourselves some more space. There we go. So this is looking much better. And as you can notice, the router deployer also asks for some parameters that we already have. So let's connect the factory address, which we're getting from the input right there, and also connect our config, which we're also getting from the inputs. There we go. So now everything is looking good. And the last thing we need is a WETH address or a wrapped Ethereum address. We can get it again by going to our node library, and then we can search for WETH and drag and drop the WETH addresses. Notice that it only has one input, which is the network. If you remember correctly, we have stored the network in the config object. So let's try to get the access to it. By now, you should be able to do that independently, as we've already learned how to get one specific property from an object. So let's just duplicate the item getter, this one right there, by right clicking it, and then clicking duplicate. We can put it above. We can pass the config as the dictionary, and the key this time is going to be network. And we can also change the name to something like let's do get network to stay consistent with our naming. Great. So now we have the network as well, and we can simply connect it to the input of the WETH addresses. Finally, we can connect the address all the way to the router. So now everything is filled in. Great. All the nodes seem to be happy. They're getting what they need now. The last thing we need to do is repeat the process we've done before. Get the contract deployment waiter from the search. So that's going to be contract deployment waiter. Here we go. Let's put it right there. Let's connect the confirmation to it. And let's set the number required to two. Finally, it spits out the contract address. So what we can do is add a couple of outputs to the right side of our node group. So we can click right there. The main output will be the router address. So router address off a type string. Then we need to spit out the router ABI as well. We're going to also have the events as well as the error. The error can actually come from two places from the router compiler, which we have here, and also from the router deployer. So let's grab both of these and bring them to the error. There we go. The ABI will be a part of a router compiler inside an object. So we first have to get the item getter. Let's duplicate the one we already have, which is going to be this one get network duplicate. Name it something like get ABI key like this. Connect the compiled router to it to the dictionary part and add the key simply as ABI in a string. Finally, it's value can go to the end under the router ABI. The last two steps are to connect the router address, which is coming from the contract deployment waiter, and also to connect the events which are coming from the router deployer. There we go. So now all of the outputs have proper values and also all of our inputs are connected as well. So this is how our node looks like. Now let's go one level above by clicking on the workspace in the top middle of the screen. As you can see, everything we've been working on so far is inside of this little node group. All right. Now let's figure out which values we must pass to our router. First one is going to be the factory address, which is coming from the factory node. This contract address might not be the best name. So let's rename it to factory address instead. There we go. So now we can clearly see that we need to connect those two. We also have to pass the config. So let's put it a bit down and let's simply connect it. And the last thing we need is a factory ABI. We can get it by double-clicking the factory node. Search for an item getter dictionary. So that's going to be item getter dictionary. There we go. We choose an item value by its key. We use it a couple of times so far. Let's drag and drop it right there. Now from the factory compiler, which is right there, we can drag the compiled factory as the dictionary. And then the key which we want to get is simply a string of ABI. Now let's create a new output. Let's call it an ABI simply. And let's connect the value of the item getter to the ABI. Now we can again go one level above by clicking on the workspace. And now we can connect that newly created factory ABI, which is right now inside of the factory. We can connect it to the factory ABI of the compile and deploy router. Now that the input values of the router are done, we can focus on the outputs. The events will be similar to the previous one. So let's simply duplicate this multiplexed event node. And let's put it to the side. For the errors, we can again duplicate the logger with message. Put it to the side as well. We can connect the events here. We can also connect the error to the data part of the error. But the message is going to say something like router compilation or deployment error. There we go. Let's style this a bit better. So it's looking good. There we go. And finally, let's add another logger node by searching for logger. It's going to be this one right there. And we can connect it to the router address. You can save our work so far by pressing Ctrl S. And then finally, let's run it by pressing the play icon on the top right of the screen. The same thing is going to happen. We can see the green lines flowing from left to right. And this process does take some time as we have to wait for those confirmations. Shortly, you'll be able to see that the final logger node light up in green. And then in the output, you'll be able to see the address of the deployed contract. Now, we can even see how it is executing things by going deeper into the compile and deploy factory node. And we can see that everything has been light up in green besides this connection right there, which means that we are waiting for the confirmations. We can even see that if we press show traffic, it is now one just moved up to two and then it light up in green, which now means that we are properly sending the information all the way to the compile and deploy router. It also light up in green right there. So we can see the data and the transaction hash. And finally, we're waiting for the confirmations right there on the logger as well, which should happen momentarily. We can see confirmation number one. Of course, we're waiting it to reach two, which should happen really soon. And there we go. In the output, we get the address of the deployed contract. Let's copy it and check it out on ether scan. There we go on a girly ether scan, simply paste it right here, search for it. We can see that it is a contract creation. And then on the top right of the screen, you can see the content creator of that contract. If you click it, you'll be able to see that there are two different contract creations happening at around similar times for you. It should be about a minute ago. The first one is the factory contract, and then the other one is the router contract. With that, we have accomplished our goal. So press control S to save it and phenomenal job reaching to this point of this video with no errors. In case you did have some errors and this logger is not lighting up in green as it does for me, no worries. We've connected a lot of notes here and things that get a bit complicated. So it's possible you misconnected some nodes or provided some wrong data. For that reason, I have created an entire structure that you can see right now and created it as a template. So down in the description, you can find a first checkpoint, which then you can load up into your crank by going to this menu, project, and then import. There you can see checkpoint one. For you, it's going to be in downloads or in desktop, simply click it and it's going to open it up. The only thing you have to do once you get it, you'll have to go to config, data, and then update these values right here from your alchemy and metamask accounts. Great. Then if you rerun it, everything should be working perfectly. Congrats on coming to this part of the video. You've successfully compiled and deployed our factory contract and then compiled and deployed our router contract, phenomenal job. And finally, before we jump into creating that beautiful UI that you saw the start that's going to allow us to exchange actual tokens, we have to add liquidity because without liquidity, no exchange can work. Having liquidity pools is essential. Let me show you how the

---

## 00:44:55 - Cranq Part Three - Liquidity

y actually work. So there has to be a liquidity provider that's going to deposit some specific tokens into our liquidity pool. That's going to form specific reserves. So let's say we're going to have 100 Ethereum there. We're going to have 10 gold, silver, and bronze tokens. That allows other traders to come onto our platform and actually make swaps for different tokens. And of course, the only reason why they can do that is because those liquidity providers have put their tokens in. So now, this person, this trader can trade. And then of course, the fee is going to be added to the liquidity provider. Just due to the fact that they were so nice, they provided us with some tokens. Great. We can also compare that to banks. For banks to be able to provide exchange services, they have to have pools of money of let's say pounds, USD and maybe some other currencies. So if you want to exchange USD for pounds, they have to have that pool of money they can give to you and that you can transact with them. Hopefully that makes sense. If you want to transact USD into Japanese yen, and they don't have that pool, then simply the transaction cannot happen. So for that reason, now we can create our liquidity pools. Fortunately, Crank has got us covered here as well. Let's open up the node palette and search for Uniswap and then let's start typing liquidities. And drag and drop the liquidities adder. It's going to be the liquidities one, plural, not the liquidity one. So let's put it right here. There we go. And as before, we can create a group to keep the complexities of this step in one place. So right click the liquidities adder and then simply say group node. Let's go under instance and let's rename it to add liquidities. Go inside this newly created group. By hovering over the liquidities adder, we can see that the first input it needs is pairs. So let's add a pairs input to this group as well. And we can rename it to pairs. Then we have to have the two address. For now, we can use the same address we used in the config. Then we have the deadline, which is the timestamp until the liquidity operation is completed. So let's create that timestamp. We can create it by creating a new store, drag and drop it. Let's call it expiration. And let's set the data to 300 seconds, which is five minutes. From that, we can generate a timestamp and crank makes that incredibly simple. On the left side, search for timestamp, getter, and drag and drop it. And if we have the current timestamp and we have the expiration, then we have to add them together. And we can do that by using the adder node. So simply take the adder, put it here. It's accepting two different parameters. So let's add the timestamp as a right here. And let's also add the expiration as B. So that's going to be the data. And the sum will be the deadline. To keep things clean, we can hold shift, select these two nodes, and then we can group them. Let's call the group, calculate deadline. Great. And let's also give it an input called start. Because as we said before, every single node to run needs a starting signal. So we can pass in something that we know will always be there. For example, these liquidity pairs. Now we can go inside of that group and connect this start to the timestamp getter inside of the get. And also to the read part of the expiration. Let's go outside of this group now. And finally, as we said, the sum of those inputs is going to be the deadline. So we can connect it right there. And also those pairs that you can see here, we are already getting them from the input. So simply connect them as well. So for now, we have the pairs, we have the deadlines, and for most other needed inputs, we'll get a data from the config. So let's create an input at the left side for the config. Config contains everything needed for the credentials. So we can immediately connect them right here credentials. Regarding the rest of the variables, we'll pull the data from the config using the item getter. We've used a couple of times before. Let's search for the item getter dictionary that's going to be this one. Pull the config into this item getter as the dictionary. And then the key is going to be a string of account address. And merge the value with the two address. And the final value called router contract will come as an input to this group. So let's create it. Router contract. And let's pair it right here. Now I want to show you one cool thing you can do with variable and parameter types in crank. If we go into the router contract part right now, which is right here, that is the input, we can give it a data type instead of the prototype right here. Currently it's set to any. It can be a string number or anything like that. But it can also be a dynamic type which crank automatically reads from other nodes. In this case, instead of any, we can type type off, router contract inside of backticks off liquidities, adder. Make sure to spell it properly. That is going to resolve this type right here inside of the liquidities adder, router contract. And it will try to pull it right inside of here. So now if you check it out, it looks good. And if you check the instance of the router contract port, it has a specific type. It knows that it is expecting an address, which is a string. And also it expects an ABI, which is an object containing a string. Pretty crazy right? Type matching for ports has enormous potential in crank. I think that's an area they plan to work on. So I think their end goal is to eliminate data type bugs entirely. So the data type checking will work across connection, not just with these parent and child type relationships. That's coming soon, but already what they're doing with this is quite revolutionary. Now this is how everything should look like for the add liquidities node group. Now let's go one level up by selecting our workspace in the middle of the screen. The router contract which we have to pass to add liquidities is a compound variable consisting of two things we're getting from the router. It is a combination of the router address as well as the router ABI. So what we can do is search for a sinker node. There we go. It's going to sync two different variables. The sinker node takes in a couple of imports and then it merges them into one output. So under fields we have to provide an array of strings which we want to take as keys. In our case that will be the address as well as ABI and make sure to spell them correctly. As you can see that created new inputs on the sinker node and now we can just connect the router address right here to the router address of the sinker and also the ABI right here. And that's going to provide us with a sink to value. Those two things together form a router contract and we can connect it to the add liquidities under router contract. The config object we already have, it's a bit to the left. So let's simply connect it right there. And finally we need the pairs. And the last input to the liquidity are our liquidity pairs. We have to store them in a store node. So let's search for store. We can drag and drop it somewhere around here and then we can move it next to the config because this is also going to be fairly static data. We have two different stores in our application. Now this is going to be interesting. I'm going to teach you how to create your own ERC 20 tokens on the Ethereum GERLY network. So let me show you how to do just that. Down in the description there's going to be a link that's going to point you to this website. Create your own ERC 20 token and we can immediately dive into the creation process. Let's enter the token name. As you can see I was creating some tokens before. So let's do just that. I'm going to call it JSM gold. And in this case the short name is going to be JSM G. That's the token symbol. The only other thing you have to provide is going to be the initial supply. So let's do something like 10 million. So 1, 2, 3, 4, 5, 6 and then one more that's going to be 10 million. Of course feel free to play with this. You

---

## 00:54:49 - Create Your ERC20 Tokens

can make it even larger but usually these tokens have huge initial supplies. Then we can leave it as a simple ERC 20 token but here's a crucial thing. You have to change the network to GERLY testnet. Not to be charged for real Ethereum of course. And we have to check this checkbox. Click next. It's going to open up Metamask and ask you to connect with your account. So click next and connect. Then you can skip entering your billing information. And finally you can click create token. It's going to open up another Metamask window and you can click confirm. The transaction is already done and the token is being retrieved as we speak. There we go. JSM gold, JSMG, feel free to call this token however you want. Put your first and last name there. Play with a symbol and play with the name as well. Now let's add it to Metamask. There we go. I'm going to add the token. And now if you go to Metamask you can notice it took some GERLY Ethereum to create that actual asset. But now under Assets we can see that we have 10 million JSMG. That is great. While we're here let's also create some other tokens that we can play with. So let's reload the page. Let's also create the JSM Silver or again feel free to call it however you want to. And that's going to be JSMS in my case. This apply is going to be same so that's going to be 1, 2, 3, 4, 5, 6, 7, 0s. And we can set it to GERLY testnet. Of course we have read the terms of use. We can skip. We can create a token. And we can again confirm. And we're now retrieving our token. There we go. Let's add this one to Metamask as well. Great. Now we have two different assets right there besides our GERLY Ethereum. What we can do is do something interesting now maybe create a new version of our own token of a generally popular token. So I'm now on coingecko.com and I switch to Ethereum ecosystem tokens. Because if you think about it you can only create ERC20 tokens on our Uniswap clone as we are on the Ethereum blockchain. So we already have Ethereum. These are some stable coins. But let's do something funny and create our own version of the Shiba Inu token. So let's go back. Let's call it Shiba Inu. JSM. And that's going to be if this one is SHIB. This is going to be SHIBJ as in JSM I guess. Of course feel free to play with this and create your own cool tokens. Again that's going to be 10 million, so 0, 1, 2, 3, 4, 5, 6, 7. And we can create it on the GERLY testnet. Skip and create token. And we can confirm. And the token has been deployed. We can add it to Metamask. And with that now alongside Ethereum we have three different assets we can play with in our Uniswap clone once we actually create the UI part of our application. But now we'll have to do something with those tokens. Remember our talk about liquidity pairs. We'll have to use those to provide them as liquidity. This huge supply there. So what we can do is go into this asset, go to these three dots, and then go to token details. There we have the token contract address. So press this button to copy it. And don't forget which one this is. I think we were on the JSM gold. Now going back to our crank. We can go into the data part of the store and we can create our actual liquidity pairs. So that is going to be an array. And that array is going to have more arrays inside of it. Our first array is going to look like this. It's going to have two objects inside of it. So one and then two like this. In there we have to pass the address. And in here we paste the address of our JSM gold. In my case, of course for you that can be something different. So you just paste it right here as a string. Then you also need to pass a second parameter which is a desired amount. This is going to be the initial price of that token when compared to something else. And we can set it to 1000. Now what are we comparing it to? Well, we can specify that inside of our second part of the pair. So we can again add the address for Ethereum. The address is just ETH. And then we can add the desired amount as well. There we go. Which is going to be set to 0.001. So we are paying a lot of gold for not that much Ethereum. But that's how it is. Ethereum is valuable. We also have to add a comma right there. Now hopefully this makes sense. We created only the first pair right here. We are exchanging the JSM gold for Ethereum. Now what we can do is we can copy this entire array. And we can duplicate it one more time below. Or let's do one more time as well. So now we have to be really careful of what we're doing here. So I'm going to zoom it in a bit. So we can see it better. So that's going to be view and then zoom in. There we go. So this is our first pair, JSM gold for Ethereum. Then let's also add a pair for JSM gold. That's the same address. But now we want to exchange that to JSM silver. So we can go back, find the JSM silver, go to token details and copy the token address. Now we can face it right there. So now we can exchange the JSM gold to JSM silver as well. And for the last one, let's say that we want to exchange maybe let's play with the Shiba token right now. So three dots and then token details and we can face it right there. And let's say that we also want to exchange that to Ethereum. So now we have provided some pairs in case you want to see more different options of being able to translate between one to another token, feel free to add all of those pairs right there. In my case, I'm happy with how it is. This is a bit of a complicated structure. So I'm going to leave this structure down below so you can actually copy it. But keep in mind after you copy it, you do have to change all of those addresses to the tokens that you have created for it to work. There's still just one little detail we still have to change. We want to exchange gold to Ethereum. And of course, Ethereum is worth much more than gold. So we're going to keep this transaction rate. But when converting gold to silver, in this case, we want to change it a bit. We want to make it that 100 gold is worth 1000 silver. So it is just 10 times as large, not this huge difference right here. Great. With that said, we can connect the data to the liquidity pairs right here. And we also need to give it a starting signal. So let's pull this start into the read part of our store. Finally, we're now passing all the proper inputs into the ad liquidity's node group. And we can go into it one final time to check what we're going to do with the output. There we go. So we can see that nothing is being outputted from this group. We can connect them. We have the result here and we have the error right there. Let's go out of this view now. And as before, we need a logger with the message for the error. So let's duplicate it from above. Put it right there and connect it. The result to the data. And then for the message, we can say something simple like add liquidity's error. And we can duplicate the logger to log out the result. So simply put it here and then pull the result into the data of the logger. I've noticed they made a wrong connection instead of connecting the result to the logger. We have to connect the error. There we go. So now it should be good. Now the last thing we have to do before we deploy our application is go inside of the ad liquidity's group node. Inside of there, we can notice that we have this calculate deadline, which gets the current timestamp and then waits some time. In this case, we're waiting five minutes. But the issue is we want to wait after the contracts have been compiled and deployed and not simply wait from the start of the code execution. And that's exactly what's currently happening since peers are generated immediately since they're just simply an array of objects. We are sending that as the start signal node. So it's happening immediately. What we have to do is right click the pairs. We need to delete that connection and then send the router contract as the initial start node to the calculate deadline node group. Great. With that said, we can go back and congratulations on completing the third and final step in our build. Let's press the play icon on the top right to start our flow. There we go. The output is starting and the project is running. As you can see, immediately a lot of things light up green. Immediately, the liquidity is already to provide a tokens. But we're still waiting for the compile and deploy router confirmations. As you can see right there, it still hasn't sent them. So soon enough, after it has two confirmations, these things are going to light up green as well. And then when they do, they're going to send the data all over to add liquidities. And then we should get something from the final logger. And remember, you can always right click the connections and click show traffic to see which data is flowing through it. So right here, we can see some addresses. These are the liquidity pools. The sinker is green as well. And we're still waiting for our final logger. While we're waiting, we can check things on the girly either scan by copying this address right here. Back on girly either scan, we can paste it right there. We can check the contract creator on top right. And you can see two contract creations happening a minute ago, meaning that went well. And now we are adding our liquidity pairs. This process is still taking some time, but it should be done really quickly. There we go. Our first ad liquidity happened, which means that we already have one liquidity pair. And I'm sure the rest will happen as well. No worries about this big number two string. This is only a warning, not an error. So let's give it a few moments. We're going to wait for it to finish. And then hopefully we see a green light on our final logger copy. And there we go. As I was saying it, we can see our liquidity pairs being listed out right there. Our logger copy is green as well. We can show the traffic, which are our liquidity pairs. And that means that we are fully done with the compile and deployment process of those smart contracts and with the addition of liquidity pools. Isn't that great? Now again, if you did have some errors, that is entirely fine. Again, down in the description, you'll be able to see the final version of our crank project. So you can download it, go to the menu, go to the project import. And then there, you can get the final checkpoint dot crack J. Then it's going to load everything up. But again, keep in mind you have to add the config data as well as the stored data for liquidity pairs from your own created tokens and also your own alchemy and Metamask accounts. Great. When you do that, you can hit start again and then everything should work with that said, we're now done on this crank side. Again, I'm incredibly happy with how this turned out. We can even zoom it out just a bit and you can see how it is looking. Again, it's just a different way to look at the code. It is quite visual. We have this flow. Everything is flowing nicely from left to right. We have some stores right there. We have some node groups. We have events and the data is just going all the way down from the compile and deploy factory to compile and deploy router all the way to add liquidity. Just imagine what you would have to do to code this out in code. It would be a mess because you would have to work directly with solidity code. This way it's just so much easier. With that said, phenomenal job on completing the crank part of this tutorial. Now we're going to focus on building the UI and UX all far uniswap clone and then connecting the crank to the front end part to make a fully functional uniswap application. The only thing you have to do right now is click this output button and then copy this address right there and store it somewhere because we'll need it once we create our React application. Great. With that said, let's get started with building our great React decentralized application. As we always do on JavaScript mastery, we're going to start off by creating an empty folder on our desktop. Let's call it something like uniswap 2.0. Great. Now that we have the folder, open up an empty visual studio code window and then drag and drop it. Once we're in, you should see something that looks like this, an empty project. Now what you can do is go to view and then terminal. This is going to open up an integrated terminal right inside of your uniswap 2.0. What you can do now is visit usedap.io when a theorem meets React. It is a framework for rapid-dap development. You can think of this technology as a create-react app or vete for decentralized applications. Essentially, it is going to create a file and folder structure that's going to connect our React application with our smart contract. Let's get started by going to the documentation. On the left side, you can select using createeadapp. The only thing we have to do is run one simple command. Back in

---

## 01:10:39 - Frontend Setup

our visual studio code, we can run yarn or mpm, create eth-app and then dot slash. This is going to create a new Ethereum application right inside of our current repository. And again, it is nothing more than a simple create-react app with some additional file and folder structure to connect it to our smart contract. So let's give it a moment for it to finish and then we'll be right back. And there we go. Our application has been initialized. Now, you're going to notice that the structure is just a bit different from our usual create-react app. Now, in here, we have the packages folder. Inside of the packages folder, we have the contracts folder. Where inside of the src, we have the abis folder for smart contracts. Soon, we're going to modify this entire contracts folder. Then we have the react-app, which is essentially nothing more than a simple react application. And then we also have a subgraph folder, which in this case, we won't need. So let's simply right-click and delete it. We can also go to the package.json. And then from here, we can also delete the scripts that start with subgraph. Just to make it a bit cleaner. There we go. Now, one more thing that we have to do right here is right under workspaces, add one more key and value pair. And that's going to be resolutions is equal to an object where we have react-error-overlay. And we can set that to the version of 6.0.9. I've noticed that this create-eat-app has a slight bug with hot reloading the react application once you save a file. So adding these resolutions right here helps to fix that. Now, as I've mentioned before, we're going to delete our current contracts folder. So simply right-click it and then click delete. And then right below this video, you're going to find a link that's going to point you to the zipped contracts folder. You can download it, extract it, and then simply paste it right here under packages. Make sure that it is not inside of the react-app. Rather, it has to be under packages. That is important, so these have to be siblings. Great. Now that we've done that, we also want to clean up the react-app a bit. So go inside of it, and you're going to notice that we have quite a lot of stuff inside of the source folder. We won't be using most of these, so simply right-click the source folder and delete it. Now, as we've done with the contracts right below this video, there is going to be an updated source folder, so simply download it, extract it, and then paste it right inside of the react-app. It's going to look something like this. It has the styles, and this is the list of some reusable tailwind styles that we'll be using throughout our application. There's no logic happening here, just some reusable styles. Then we also have the utils folder inside of which we have helpers. This is a list of functions that's going to help us develop our application. We have functions like get available tokens, get counterpart tokens, and find pool by tokens. These are just some simple helper functions that will help us clean the data that we get back from the blockchain. Every single line of code that is dealing with actual Web3 logic and pulling the data from the blockchain will be coded by you. Then we have some states just to simplify the logic are recurrently pending, are we allowing the transaction, has it failed, has it succeeded, and we also have a simple helper function to get the failure message as well as the success message. Again, nothing major just helper functions. On top of that, we also have our app, which cannot be simpler. It is a simple functional component that says hello Web3. Then we have the config.js. Instead of here, you're going to put your own router address that we got back from crank and also your own alchemy URL right here. Then we have some basic styles where we import tailwind. Finally, we have an index.js where we wrap everything using the use.dap.dap provider. This was already there, but we deleted the source folder, so now we brought it back in. As you can see, this is the main part where we're importing the app config and then we are wrapping our entire application with that.dap.dap config. That's essentially what used app create.dap is it takes a react application and it wraps it with its own that provider. Great. With that said, you now fully understand our initial source structure and we can continue. The next thing we have to do is install tailwind. In this case, there's version mismatch between react and tailwind, so we decided to use tailwind CDN. It is a way where you simply add a script and it includes the tailwind right inside of your project. And to bring tailwind into our project, you can go to public and then index.html. We have a lot of things happening here, but if we indent it properly and remove some of these comments, you're going to notice that this is nothing more than a simple HTML5 document. So one more time, you can go down into description into a GitHub gist and there you're going to find two scripts that we can add to our index.html, which you can add above the title. It's going to be a script for tailwind CDN and then also the tailwind config. And finally, to make sure that we're using the same versions of dependencies, you can go inside of your React app, package.json, and you're going to notice that some dependencies are already installed here. What you want to do is for one final time, trust me, go into the description, go to that GitHub gist below, and then simply paste a couple of dependencies that we'll be using throughout our application. There's going to be only one that's going to be mentioned twice, which is the use.dapp core, delete the one that is right here, which is an older version, and simply use the one that is right there in the GitHub gist below. Great, so it should look something like this. I know that this was a lot of setup and a lot of configuration, but trust me, now we have set everything up and we are ready to start coding things out. So what we can do is finally run the application. So go to view and then terminal, let's clear it. And finally, we need to run mpm install to make sure that you have all the latest versions of dependencies. This process is going to take about a minute, so I'll be right back. Now that our application is running, you can go to the package.json to check the start script, and in this case, it's not going to be simply mpm run start, it's going to be mpm run, and then we have to save React-app colon start. So one more time mpm run, and I will suggest using mpm here, I was having some issues with yarn. So mpm run React-app and then colon start and press enter. This is now going to start our application on localhost 3000. And there we go. Hello, web3. This means that we have successfully configured our project, and we are ready to start coding the UI and the UX of our great application, and start connecting it to the smart contracts we have compiled and deployed before. So with that said, huge props to you to coming to this part of the video. Now the fun part begins. To get started building our great application, let's go into packages React-app source and then app.js. This is where the magic happens. We are importing React from React. Let's also import a package called useethers, and that package is coming from add use.dapp-forth-slash-core. That is that main package that allowed us to create this file and folder structure. We are also going to import styles from .slash-styles. Let's also import inside of curly braces uniswap-logo, and

---

## 01:19:54 - Layout

that's coming from .slash-assets. If we look into that, you should have the assets folder inside of your source folder. Great. That's going to be all that we need for now. Now let's focus on creating our initial layout of our application. We're going to wrap everything with a div. Let's create a div. That div is going to have a class name equal to styles.container. It's going to be dynamic in a sense. Now might be a good time to open up the browser side by side with the editor so that we can see the changes that we make live. There we go. The browser is on the right side. For now, we just have a dark background. Inside of that div, let's create one more div. That's going to have a class name equal to styles.innercontainer. Inside of that inner container, we can put our header. .header is of course going to have a class name of styles.header. That's going to be essentially our navigation bar. Inside of there, we can put an image, which is going to be a self-closing tag. We can give it a source of uniswap logo. I'll tag equal to uniswap logo. Let's also give it a class name equal to w-16, h-16, and then object-contain. Now if we save it, you should be able to see a logo right there. It should be a bit smaller for you as I was on the 500% increase. So now let's zoom it in just a bit. There we go. The uniswap unicorn. Below that image, later on, we're going to render a new wallet button component. So for now, let's simply hard-coded as wallet button. Now going below our header, we can have a div that's going to have a class name equal to styles.exchange container. So this is where the exchange will actually happen. Inside of there, we can create an h1, and that h1 is going to say uniswap 2.0. We cannot see it yet as it is dark, but as soon as we give it a class name equal to styles.head title. And save it. You can see a huge uniswap 2.0 text up here right there. And if you're wondering where these styles coming from, you can control click these styles, and it's going to lead you to the index.js inside of the styles folder. And there you can see all of the tailwind CSS classes we have used. Great. Now below that h1, we can also put a p tag. And that p tag is going to say exchange tokens in seconds. And let's also give it a class name, something like, or not something, precisely like styles.sub title. There we go. That is looking great. Let's expand this just a bit. There we go. So we can see the code better. And now below that p tag, let's leave some space and then create one more div. This div is going to have a class name equal to styles.exchange box wrapper. And one more time just to repeat, if you want to see what the styles are about, control, click them, and you can see exactly which tailwind styles we have used inside of there. There's going to be one more div. And then this div is going to have a class name equal to styles.exchange box. So this is going to be for that uniswap box. And then finally in there, we can have a div. But this div is going to be self closing. So now if we save this, you can notice we have some lines there. And this div is going to have a class name equal to pink underscore gradient like this in a string. That's going to provide just a slight gradient at the top of the box. We can also duplicate that gradient and then change the bottom one to blue as we're going to have that blue and then pink radians. Great. Now in the middle of those two gradients is where our actual exchange box is going to be. So let's create a div. And that div is going to have a class name equal to styles.exchange. That's immediately going to create this great looking box. And I think now is the time that we actually zoom it out. Inside of here, we first want to check if we have a connected metamask account to our decentralized uniswap application. So now might be a good time to check that functionality. Connecting your decentralized app to metamask might be simpler than you think. The only thing you have to do is go all the way to the top of your application and then say const, this structure account coming from or rather is equal to use ethers. And this is the function coming from the use dab core. So this is going to give us access to your metamask account if it is connected. So now what we can do is maybe just showcase it here. Let's see if it exists or not. Of course, we would have to put it inside all of a p tag right here. And let's give it a class name equal to text-white. So right now we cannot really see anything. And of course, that's because our account is not connected. So for now, we're just going to use this account for conditional logic. So let's open up a dynamic block and say if account exists, then we want to have one additional check. If pools are loading. So if pools are loading, then we want to show a loader. So right here, we can render a loader component like this. So if we have the account and if the pools are loading, then we can display a loader component. If we have the account and the pools are not loading, then we can render the exchange component like this. And then finally, if we don't have an account, we can also simply showcase a loader component. So let's render a loader right there. There we go. So we have two loaders and we have the exchange. Now, there's a couple of things which we don't yet have the access to. One is the pools loading. We don't know what that is. So for now, let's create that as a static variable at the top. Const pools loading is equal to false. But now we have to do the actual components. We have the loader component. We have the exchange component. And we can also transfer this wallet button to a component of its own. So now we know that we have to create those three components to create those components. Let's go into our source. Let's right click it and create a new folder called components. Inside of there, we can create those three components that's going to be a wallet button, .js. Then we're going to have exchange, .js. And finally, we're going to have a loader .js. For each one of these three components for now, we can simply run R-A-F-C-E. That's going to create an empty functional component. If this seemed like magic to you and it didn't work, you might have to go to the extensions folder and then search ES7 plus. And then that's going to be react, react native snippets. So simply install this extension and it's going to work. Now we can repeat the process for these two other components as well. And we can create a new index.js file inside of the components folder to export all of these components in one place. So that's going to look like this. Export default as loader. Coming from that slash loader. We can duplicate this two times and then simply change the loader to exchange and then change the loader to the wallet button. There we go. So now we're exporting those three components and now going back to our app, now we can import them. So at the top, we can say import exchange, loader, wallet button coming from that slash components. There we go. So now we have everything we need. Of course, we cannot yet see them because everything is dark, but the wallet button is indeed here at the top. It is barely visible next to this unicorn. Great. So now we can actually render the loader, which is currently being shown right there. Now these two loaders are not going to be identical. Each one is going to have a different title. So let's add a title prop. The first time we do have the account, but the pools are loading. So let's leave a message, something like loading pools and then please wait. And of course, when I say pools, I mean liquidity pools. The ones we talked before, someone has to provide liquidity for us to be able to make transactions. And then for the bottom loader, we can provide a title equal to please connect your wallet because this would only show if the wallet isn't connected. So now let's go inside of the loader component and let's code it out. We can first import styles coming from dad that slash styles. And then we can import the Ethereum logo coming from dad that slash assets. Now we know that this component is accepting a title prop, which we passed. And now we can focus and rendering it out. So we're going to wrap everything in a div. And let's give it a class name equal to styles dot loader. Great. Now inside of there, the only thing we want to do is render one self closing image that's going to have the source equal to Ethereum logo. The Alt tag is going to be also equal to Ethereum logo. And then the class name is going to be equal to styles dot loader. I am G. There we go. If we save that, we can now see this huge, colored and matching to our theme Ethereum logo. Below that, we can create a p tag that's going to simply render the title in this case that can be a class name equal to styles dot loader text. If we save this, we can now see please connect your wallet. And this is looking great right off the bat. So we can go outside of the loader, expand this, hand it's already looking great. Now let's focus on adding that connect wallet functionality, which is going to be inside of the wallet button. So let's control click to go into it. And let's start implementing it. First, we can import the use state and use effect hooks from react. We can also import a couple of dependencies from use.dap. And these are going to be shortened address, use ethers and use lookup address. These are coming from ad use dap forward slash core. And finally, let's also get the styles inside of this file as well. So that's going to be import styles from dot dot slash styles. We can start by getting something known as ENS Ethereum name service lookup. So let's say const inside of curler braces, let's name it ENS. And then that's going to be equal to use lookup address. Great. It should look something like this. We can also get a couple of things from use ethers things like account, activate browser wallet and also deactivate. And that's equal to use ethers. So we're using two different packages. We're using the use dap core and also the use ethers package. I'm going to move the editor a bit more to the right. So we have a bit more space to work with. And then our app is responsive anyhow. So we can move it right here. Great. Now that we have those, let's also create a use state of our own. So just at the top, we can say const. Let's call it rendered and also set rendered. That is going to be equal to an empty use state, which is simply an empty string. This is going to help us determine if we want to show an actual button or an address of the account that is or the connected. So let's focus on creating that button. Instead of a div, we're going to create an HTML 5 button. It's going to have an on click property right here. And that on click is going to be a regular function there. We want to check if there is no account. Again, account is coming from the use ethers. And right now there shouldn't be an account because we haven't yet connected it. In that case, we can call the activate browser wallet. So once we click this button, if there is no account, we want to activate not active activate. The browser wallet. And let's also change that here because it looks like I misspelled it. And then else, we also want to deactivate it so we can call the deactivate not deactivate just deactivate right there. Okay, that's looking good. Now we can also provide a class name to this button. So let's say class name is equal to styles dot wallet button. Now at the top right, you can see our pill looking button. And of course, we have to say something in there. So we can say if rendered is triple equal to an empty string as it is at the start, then meaning and end if that is true, we can render a string that's going to say connect wallet. Then if the rendered is not equal to an empty string. So like this, so if it has something in there, in that case, we want to render the rendered. That's most likely going to be an account address. There we go. So now we have a button that says connect wallet. That's because our rendered is set to an empty string. Then also our account is not existent. So the button click is actually going to prompt us to create an account. So now you might have to reload the page and then click connect wallet. As you can see, in notification is going to appear and it's going to ask you to connect with Metamask, which we're going to happily accept. So let's click next and then connect. Now it's connecting, but as you can notice, it's still saying connect wallet. And that's because we haven't actually changed the rendered function. We want to show the actual address. So let's create a new use effect field or a hook. It's going to accept a callback function and then a dependency array. We want to recall this use effect whenever the account changes, the ENS changes or the set rendered changes. There we go. So in here, that's supposed to be ENS. And now that I'm looking at it, it might be a good idea to rename the rendered as that is a bit confusing to something like account address. So click on the rendered press F2 and then rename it to account address. And then also rename the set rendered to set account address. There we go. So now this makes a bit more sense. If the account address doesn't exist, meaning if it is an empty string, so we can say if no account address, then show the connect wallet. Otherwise, simply show the account address. So that's going to look like this. There is also a shorter way of doing this. We can say if account address, then show the account address. Otherwise, simply show the connect wallet. But then there is an even shorter way of doing this is when you have the first parameter and the second parameter of the turnery being the same, you can simply say show the account address or show connect wallet. So you can see how much we simplified it. This just makes so much more sense right now. But now, let's actually update the account address right here. We can say if ENS exists, then we want to set account address to be equal to ENS. Then we want to have an else if else if account exists, then we want to set the account address to be equal to account. But we want to shorten it first. So this utility function is coming from the use tab, shorten address and we shorten it. And then finally, inside of the else, we simply want to set account address to an empty string. There we go. So now if we save this, you're going to see our great looking button and it's going to render the account address because we're or the locked in. Now, it looks like there's a mistake with the hot reload. I mentioned that at the start. I cannot seem to click the button right now because we made some changes in our code. Again, that is a bug in this specific version of create React app. But that's fine. Just reload the page and you can now click the button. If we click it, it's going to disconnect us. And then if we click it again, it's going to connect us. So this is working properly. Now, if we are disconnected, it's going to show this great loader, which we can see right there. Please connect your wallet. But if we do connect it, then it's going to show the exchange, which means that our next step is going to be to start working on the exchange, which is at the same time the biggest and the toughest component of our entire application. The exchange is going to contain most of the logic of our app. So if you're thinking of taking a break, now might be a good time to do so. But with that said, let's dive right into coding out the exchange component to start with our exchange component. We will have to import quite a few dependencies. Let's start with a use state hook coming from React. Then we're going to also need to import something known as a contract with a capital C coming from at Ethers project forward slash contract. We're going to also need something known as a be eyes. And that is coming from at my dash app forward slash contract. We're going to also need to import something known as ERC20. Use contract function. Use Ethers use token allowance. This is going to allow us to see if the user has allowed for a specific amount to be transacted. And then finally use token balance. And all of this is coming from use that forward slash core. Of course, with an ad sign in front, we're going to also import Ethers coming from Ethers. We're going to import something known as parse units coming from Ethers forward slash lib forward slash utils. This is going to parse our strings into big numbers. And these are all the external imports that we need for now. Now there will be a couple of internal imports. So we can say import inside of curly braces, all caps, router underscore address. And that's going to be coming from dot dot slash config. So this is the perfect time to go into this config and to add our own router address here and our alchemy URL here. The best way to do that might be to go back to our crank. And then in here, we can of course check the data part of our store or config. And there we can see our provider URL. So let's first copy that. Bays the provider URL right here. It's going to be a string. And then finally, we have to copy the contract address we got from the output. Now, as you can see, since we reran, crank, we don't see the output anymore. But I've told you before to save that address somewhere. So hopefully you did. You can then copy it and then paste it there. Thankfully, I did save my router address. So I can paste it right there. You can do the same. And that's going to be it for our config. Now we can go back into the exchange and continue implementing it. There is going to be just one prop that we need to pass to our exchange. So if we go back to our app, you can see it's recurrently not passing anything. And also these pooled loadings are hard coded. So instead of hard coding that let's actually implement it to implement our real pool

---

## 01:41:54 - Web3 Logic

s and pools loading. We can import something known as use pools. So right here import inside of curly braces use pools. And that is coming from dot slash hooks. So those hooks, if you look into them right there, don't yet exist. We just have the utils folder. So let's go ahead and right click the source folder and create a new folder called hooks. Inside of there, we can create a new file. And that file is called use pools dot JS. Alongside that file, you also need to add an index dot JS file. From this file, we're going to export our pools. So we can say export use pools coming from dot slash use pools. Great. And now we can come back to our use pools. Instead of this file, we're going to implement the logic to get our liquidity pools. So let's start from scratch by importing web 3 from web 3. Now this is the first time that we're using this package. This is one of the most popular package people use when interacting with smart contracts. We're also going to import the use state as well as the use effect hooks coming from react. And let's also import something called use config coming from add use.app forward slash core. Now we have all of the external imports we need, but we're going to need also a couple of internal ones. So we can import the router address. And that's going to be coming from dot dot slash config. We created it not that long ago. And you put your own router address right there. So for this step, it is crucial that you have pasted it right here. Of course, if you were to deploy this on the main net, it might be a good idea to put this inside of the environment variables. We can start by creating our own custom hook. So let's say export const use pools. And that is going to be equal to of course a functional component. Instead of here, we can say const and then we can get the read only chain ID and also read only URLs. This is inside of the curly braces and it is equal to use config coming from use.app. If you hover over it, it's going to give you more information. It says right here chain ID of a chain you want to connect to by default in a read only mode. And you can also get more info on read only URLs. That is coming from the use config. Then we want to create our own state of loading as well as set loading. And at the start, it's going to be set to true. Finally, we also want to create our own state of pools, set pools, and at the start, it's going to be equal to an empty object. Now we have all of the states that we need. Now our custom hook is going to return an array of loading and pools. But of course, this doesn't make any sense as the loading is always going to be true and the pools are always going to be an empty object. So what we have to do is create a new use effect that's going to have a callback function as well as a dependency array. This function is going to rerun whenever the read only URLs or read only chain ID changes. So if those variables change, this function is going to be rerun and there we have to fetch our pools. We can do that by creating a new function, export, const, load, pools. It's going to be an asynchronous function that's going to accept the provider URL. And that's going to be an error function. Now how do we get to the provider URL? Well, what we can do is call it. So that's going to be load pools. And then inside of there, we can tap into read only URLs and then we want to get read only chain ID. This is going to return the exact provider URL we need. This is a synchronous. So we can call a dot then function on it, provided a callback function, and it's going to spit out pools right there. The only thing we want to do then is set pools to pools as well as set loading to false. There we go. But of course, this is not going to work right off the bad as our load pools is currently empty. So we are yet to implement the logic to fetch our liquidity pools. Now inside of there, we can get an instance of the provider. So we can say const provider is equal to new web 3 dot providers dot HTTP provider. And then in there, we have to pass the provider URL, which we're getting from the use configs read only chain ID and read only URLs. Now we can also create a new instance of web 3. And that's going to be equal to const web 3 is new web 3 with a capital W and then we pass in that same provider. Now that we have the instance of web 3, we can actually grab the router info and the factory info. And this will be a bit tricky, but that's why you are here. You're here to learn. So let's say const router info is equal to null for now. And also const factory info is going to be set to null for now. So how are we going to get that information? Well, that is going to include a bit more code. So a good idea would be to create a new function inside of the utility functions. So inside of utils, let's create a new file called get router info.js. And we can also create another one called get factory info.js later on, there's even going to be a third one called get pairs info digest. So now we have all of these files right there. Let's first export them inside of the index. So just above the export of helpers, we can also say export inside of curly braces, get factory info from dot slash get factory info. We can repeat that by saying export get pairs info from dot slash get peers info. And finally export get router info from dot slash get router info. Now of course, we have to create those functions in each one of them. So let's simply say const get factory info is equal to an asynchronous function right here. And we can immediately export it. Now we can do that for all the files. So just rename this to get pairs info. And then the last one is going to be get router info. Great. So now we have those util functions, which we can call inside of our use pools. So let's first import them. In this case, we're going to need two that's going to be get factory info as well as get router info from dot dot slash utils. And now what we have to do is a wait get router info. We have to pass our router address and the instance of the web three. The router address was misspelled right here. So if you fix that, we should be good. So now we know that we're passing the router address and the instance of web three to the get router info function. So let's control click into it. And let's implement it. The first step is going to be to get the router address and web three. And we can also import something known as import ABI's. And that's going to be coming from at my app forward slash contracts. And if you're wondering what an ABI is while interacting with a smart contract, ABI is one of the essential components. So essentially, ABI is an application binary interface. And it is an interface between two program modules. It allows us to interact with the smart contracts we have written. With that said, how do we use that ABI to get that contract? Well, let's say const router is equal to new web three dot eth dot contract. And then in there, we tap into the ABI's, we get the router zero two. And then the second parameter is going to be the router address. Finally, we want to return an object. That is consisted of one property called factory. There, we can await router dot methods dot factory. And then we call it you're going to notice that some of these things are going to be repeated in a lot of web three applications. We have to get the information from the smart contract using the ABI's and the addresses. And finally, we're returning the factory for that smart contract. Great. That's going to be it for the get router info. Now the second step is to get the factory info. So for that, we can await call the get factory info. It's going to accept the router info dot factory. And also, it's going to contain the instance of web three. Now, let's get into the factory info. And now, this is going to be a bit more work as we'll have to get all the fees and all the liquidity peers. So let's start by importing ABI's from add my app forward slash contracts. And then also import get pairs info, which is going to be coming from that slash get pairs info. So that's going to be our third utility function we talked about. But let's take it slow. We know that we're accepting two different parameters, the factory address as well as web three. First, we want to get the instance of the factory. So we can say const factory is equal to new web three dot eth dot contract ABI's that factory. And then we pass in the factory address. This was created in crank. Then we can form a new object called factory info, which is going to for now be an object that's going to have a couple of properties. It's going to have a fee property. Then which for now, we can set to now it's going to have a fee to setter property, which again, we can leave as now. It's going to have the all pairs length property as well as all pairs property. So how are we going to get all of these values? Well, all of these are already built in methods on our factory. So let's simply hold alt and then double click all the nals right there. And then start typing a wait factory dot methods dot fee call it and then dot call, which we again call as a function. Now it's always going to be the same, but it's not going to be fee, rather it's going to be the name of our actual object key. And then all pairs can be left as an empty array because we're going to dynamically go through it to fetch all liquidity pairs. To loop through all of our liquidity pairs, we can do the following. Let's open up a for loop. Inside of there, we're of course going to initialize I to zero. I is less than factory info dot all pairs length. This is a property we created not that long ago. Then we can of course increment I. And then inside of there, we're going to tap into our object. So factory info dot all pairs. And then we're going to loop through them by increasing the I. So we're going to keep adding new liquidity pairs for however many pairs there are. That's going to be equal to a wait factory dot methods dot all pairs. We're going to get the I number of pair and then dot call great. That just added all the pairs. And also now that we have those pairs, we want to get additional pairs info. So we can say factory info dot pairs info is equal to a wait get in this case, it's not going to be Paris. It's going to be pairs info. And then if we fix that, we can call that and we'll have to pass two different parameters that's going to be factory info dot all pairs. So those pairs that we loop through, we now want to pass them over as the first parameter to our own get pairs info function. And then we also want to pass the instance of web three. Great. Of course, now we have to remove this pairs from here. And we have to go into the get pairs info function, which is the third in a row utility function we have created. This one will be a bit longer, but it is how it is. We're going to repeat the process of importing different ABI's from add my app forward slash contracts. And we already know what we're getting. We're getting the pair addresses as the first parameter. Let's make sure to spell it properly. And the instance of web three. Now initially, we can set the pairs info to be an empty array. Then we can get the pair ABI. So const pair ABI is equal to ABI's dot pair. Then we can also get the token ABI, which is equal to ABI's dot ERC 20 dot ABI. And now we'll have to loop over all of the addresses to get more information on each specific liquidity pair. So to do that, we can create a new for loop. We can say let I is equal to zero. I is less than pair addresses dot length. And then I plus plus. If you can see that GitHub Copilot is trying to out of fill my entire function, which essentially means that this is the code that you'll be writing quite often. But of course, I won't cheat here and use GitHub Copilot. We're going to write it from scratch on our own. So let's start by saying const. Pair address is equal to pair addresses. And then I want to get the current one. Then we need to get a specific pair by saying new web 3 dot eth dot contract. We pass the pair ABI and then we pass the pair address. Now there's going to be some repetition. There are two sides of a pair, right? There's always going to be two tokens. So let's say token zero address is equal to a weight pair dot methods dot token zero. And then dot call. Now we can duplicate this. And the only thing you have to change is token zero in the name and at the end, to token one right here. So now we have both addresses of token zero and token one of that specific liquidity pair. Then we want to repeat the process for the token zero contract. So we can say token zero contract is equal to new web 3 dot eth dot contract. We pass the token ABI and then we pass the token zero address. So this is going to give us the contract of token zero. We can duplicate that. Call it token one contract and then pass the token one address. And then finally, we have to get the name of those tokens. So let's say const token zero name is equal to a weight token zero contract dot methods dot name dot call. And then we can repeat the process for getting the token one that name as well. As I said, it is a bit repetitive, but now we have all the information that we need. Now remember, we're still inside of a loop. So we are repeating this for every single new pair that we go through. So inside of the loop, we want to tap into the pairs info, which is this array we created at the top and we want to fill it in. So we can call a dot push method pushing an object where the address is going to be equal to the pair address. And then we also want to pass the token zero address as well as the token one address as well as the token zero name. And finally, token one name. So now we're passing everything we need to our pairs info. Finally, at the bottom outside of this for loop, we can return the pairs info. And that means that this function is going to do what it was designed to do. Get the pairs info. It was a bit of code, but as I've told you in the beginning, while we're copying those files, we didn't copy anything that was crucial to the code. This part right here is crucial, working with different pairs, working with ABIs, working with smart contracts. I know it's easy and I know it's different, but it is new and it is important. As wep3 is getting more and more popular. And things are moving to the blockchain. With that said, hopefully this makes just a bit sense. So now we can go back into the get factory info where we initially called the get pairs info. Now we filled our factory with everything and at the bottom line, 20 of the get factory info file, we are ready to simply return the factory info, which means that the get factory info has fulfilled its purpose as well. Now we have the things strong and hard to figure out where did we initially call the get factory info as we did spend some time away from that original file. But that was inside of the use pools custom hook. See, we have the get router info and then get factory info. Perfect. Now that we filled it up, let's simply return it by saying return, factory info dot pairs info. And now our load pool's functionality is done as well. We're loading up those pools whenever the read only or else or read only chain ID changes. And then we're simply returning the loading and returning the pools whenever we call the use pools custom hook. So everything is entirely dynamic and separated into a lot of different utility functions. This is the definition of clean code. Great. Now props to you if you remember where did we want to initially call the use pools custom hook. It was inside of the app.js. We imported the use pools, which now we are ready to finally call. So let's say const, we're going to get the loading and the pools. There we go. And that is inside of the square brackets and that is equal to the use pools function call. It seems like a tiny little harmless hook call. But actually it is a beast of a hook. So now we are getting the loading and the pools. We can delete the pools loading. We can now rename the pools loading to simply loading right here. And the more important part is to pass over the pools as a prop to our exchange. So now our exchange component can get the pools right here from the props and it can work with them. Ladies and gentlemen, we are ready to start creating the exchange component. Before we start developing our exchange component, there's a little small check we have to make to make sure everything is all right and we're good to go. The first check is to go to our files and check if you have the index.js file inside of the hooks because we have to export those use pools. We worked so hard on the second thing is to open up the inspect element or rather the console. And then in here read out the errors. We do have one error online eight of get factory info. So let's go to get factory info. That's going to be inside of the utils and there online eight instead of fee. We have to name this fee to so it's going to be fee to dot hole. There we go. Now if we reload we no longer have any errors. We can get back to the exchange component and we can click connect wallet. There we go and connect. Now you can notice that it still says loading pools right here which means that we still have one more error. So if we go to our console you can notice right here that it says type error cannot read properties of undefined reading pairs info on use pools 15. So let's go to use pools and check the line 15. So that's going to be factory info dot pairs info. So what we can do to test this out is simply console log the factory info to see what we're getting back. We can even put it inside of an object. So it's going to be easier to see and let's reload the page right there factory info is undefined. That means that we're not getting back the correct info from our get factory info utility function. So let's go into it. There we're creating the factory. We have all the factory info right there. Oops, but we made one huge error and that is we never returned anything. So after we populated everything into this factory info object we of course have to return it. There we go. After we do that now factory info is going to be there and we're returning the pairs info from the factory info. So now if we go back to exchange, reload the page. Now you can see that we are connected and you can barely see it says exchange right there which means that we are in the right component and we are ready to start developing it. Our exchange component will be a bit bigger as it's going to contain a couple of inputs, a couple of buttons and balances. So what do you say that we start from the UI and then we can move to the functionality. So first we're going to have a div with a class name equal to flex flex dash call W dash full and then items dash center. Inside of there we're going to have one more div and this div is going to have a class name equal to margin bottom eight. Inside of there we want to render two different components. We want to render the amount in component which is going to be a self closing component and then below that we want to render a self closing balance component as well. Now we can duplicate this entire inner div just below and instead of amount in we're going to have the amount out there we go and we can also give it W dash and then in square brackets 100%. So now you can see that we already need to create three different components the amount in the balance and the amount out and then later on we're going to pass all the props to them. So let's go ahead and do that immediately. We can go to our components and create three new components amount in .js we can run r a fc in there. Let's create the amount out .js and again run r a fc in there and finally let's create the balance component so that's going to be balance .js and again run r a fc in there. After we do that we of course have to export them so let's duplicate this three times the first one is going to be amount in the second one is going to be amount out and the third one is going to be the balance. Now we can close all of that and go back to the exchange and we can of course import those components so we can say import inside of curly braces we're going to get the amount in the amount out and then finally the balance and that's going to be coming from just .slash as we are already in the components folder finally we also have to get the styles so let's say import styles from .slash styles there we go and the last thing that we need are going to be those utility functions that we have inside of the helpers. Remember if we go inside of utils there was this file that I provided you at the start. This is going to be just the series of useful functions we can call from inside of our exchange. Again nothing groundbreaking here but it's definitely going to be helpful and it's going to save us some time so let's import all of these helper functions by saying import get available tokens and that's going to be coming from .slash utils there we go we also have get counterpart tokens so this is going to be useful when you have one token you want to change to something else you need to know to which other tokens can you change that token too then we also have find pool by tokens because once we actually decide on what we want to change we need to find an available liquidity pool then we have the is operation pending so are we currently doing something and we have a getters for get failure message as well as get success message and that's going to be all that we need for now when it comes to those helper functions great we also have those components it's hard to see them right now as they're dark but they are right here so once the pool is load we're going to have our exchange and you can see amo

---

## 02:08:41 - Exchange, Inputs, and Balance

unt out and balance and amount in and balance as well and that's going to be enough to start so now we can head into the amount in and we can focus on its functionality as well as UI and UX so inside of here we're going to import a couple of hooks that's going to be use state use effect as well as use ref we're going to also import something known as a chevron down and that's going to be coming from assets it's going to be a simple then of course we need to get the styles so we can say import styles from da da slash styles and finally we can import one helper function called use on click outside and that's going to be coming from da da slash utils this is going to help us to close that menu bar once we actually click outside of it you're going to see quickly what it does now let's focus on creating that input first we're going to have a div and that div is going to have a class name equal to styles dot amount container now you can immediately see a grayish color right there inside of there we're going to have an input this input is going to have a placeholder equal to zero dot zero it's also going to be of a type number it's going to have a value equal to value which we don't already have so for now we can hard code it to simply an empty string it's also going to have a disabled property which for now is going to be set to false later on we can switch it dynamically it's going to have an on change property which for now we can leave as an empty callback function and it's going to have a class name property which is going to be equal to styles dot amount input now if we save that you can see our great looking input right there but of course now we have to add the ability to choose the token we want to swap so below that input let's create a div that div is going to have a class name equal to relative and it's going to have an on click property once we click it for now we're going to simply have a callback function but later on that's going to open up our menu inside of there we can create our button that button is going to have a class name equal to styles dot currency button there we go you can see just something on the right side right there and then we're going to also render the active currency which right now we don't have so let's simply hard code it to something like EDH for Ethereum there we go and now we can also show an icon right there so people know that it's clickable so that's going to be an image with a source equal to chevron down there we go and let's also give it an alt tag chevron down and let's give it a class name so what we can do is let's make it dynamic and let's make it a template string w is going to be for for width age is going to be for height it's going to be set to object contain margin left is going to be two to divide it from the letters and then later on we can rotate it up and down based on if the menu is currently opened or closed so for now I'm going to simply say true it's always going to be true for now later on we're going to do it dynamically so if true then rotate dash 180 in a string else simply rotate dash zero there we go so now if you save this you can notice it gets rotated once this value changes so if we set it to false it's going to be set to down of course this is going to be dynamic soon enough and you know what we can immediately make that up and down work so for that we would simply have to create one new use state so let's call it use state it's going to be called show list and set show list and at the start it's going to be set to false now based on that once we click right here on this div then we want to set show list to be equal to not show list this is usually not the best way to do in react the react documentation discourages you to simply update the state using the previous version of that state so what we can do is provide a callback function inside of the set state there you get the previous state so prep state as the first parameter and then you can say not previous state so this is the proper way to toggle it in react of course before we test it out we have to set show list right here so let's say show list right there now if you save it it's not going to work immediately because we are having those issues with hot reloading in development but don't worry that's going to be fixed in production for now we can simply reload the page wait for it to load and then we can explore it in action it's actually working now once we do click it we want to show a menu so below this button we can create a new dynamic property where we check if the show list is true and then only then render the following code that code is going to be a UL an unordered list and we're going to give it a class name equal to styles dot currency list there we go now inside of there we will have to map through our currencies for now we can really do that as we don't have the list in this component yet so it might be a good idea to simply hard code them right there so let's create a new dynamic block of code let's create an array each array is going to be an object where we're going to have a token which is going to be set to let's say eth and then we're going to also have the token name right here so token name is going to be set to eth as well later on the token is going to change right here to the actual token address so these are not going to be the same but just since we're mapping through it we can keep things simple now let's duplicate this just so we have a couple of things there and let's rename this to jsm gold there we go now we can call a dot map functionality on it so that's going to be dot map for each one of these we want to destructure the token as well as the token name and then we also want to get the index then we want to instantly return something so use just regular parentheses right there for each one of these we want to show an ally that ally is going to have a key and the key is going to be set to index we're also going to give it a class name but we have to know if this class name is currently selected or not so let's make it dynamic it's going to be a template string it's always going to have a styles dot currency list item but now we have to check if it is currently selected so we can say let's simply do true for now so it's always going to be selected and then we can give it a bg dash site dash dim 2 and then if it is not selected we can simply set this to an empty string and always it's going to be a cursor dash pointer so now if we save this nothing is going to show yet and that's because we didn't add anything inside of the ally and there we want to render the token name so now if we save this and reload the page because of that hot reload bug and then click here you can see that it actually opens of course this is just the fake data for now but soon enough we'll be fetching real data from the blockchain great with that said that's going to be it for the UI of the amount in component later on we're going to provide a lot of different parameters to it so it's going to actually work with that said we can now go back to the exchange and focus on creating our amount out component you might think that these are going to be quite similar as they're going to look almost exactly the same and they're both kind of inputs but they are also different the first one is an actual input where you'll be able to type different values but the second one is just an output it's going to show you how much of its specific currency you can get for the selected input with that said we can start by simply copying the entire amount in and then placing it in the amount out and of course rename it to amount out right here so as I said some parts will be similar but the majority will be different so now we have two of these which is looking great but in this case the placeholder will be the same the type is going to be a number value we're going to get later on then disabled is going to be always true so we can simply leave it like this because you won't be able to type into the output input and then also the class name can be the same the on change we won't really need as it is a static input and that's going to be it for now of course we're going to pass in the real values soon enough now let's focus on the shared component for both input and the output which is the balance we can move into the balance and this one is going to be much simpler we're going to import just two different utility functions from ethers that's going to be format units as well as parts units and that's going to be coming from ethers forward slash lib forward slash utils we can also import these styles coming from dot dot slash styles great now inside of here we're going to wrap everything in a div that's going to have a class name equal to styles dot balance we're going to also have a p tag right there that's going to have a class name equal to styles dot balance text and then there we have to check if we do have any balance for now I'm going to hard code it so let's do something like const let's name it token balance and let's set it to a string of 0.0025 something you can do whatever you want now we can check if the token balance exists so that's going to be token balance and then we can simply say and end so if it exists show something in this case we want to show a react fragment and then inside of it there's going to be a span element with a class name equal to styles dot balance bold there we can say balance make sure to put one space here and then below it we can call the format units and then in there we can render the token balance in case the token balance doesn't exist we have to provide something else so if the token balance doesn't exist we can provide a parse units call of 0 this is going to make sure that we don't have any errors as format units always expect one big number value so this parse unit is going to pass this string of 0 to a big number now we do have one error so let's open up inspect element and go to the console we can notice that we have an invalid big number of 0.00251 so this value that you're passing right there should already be a big number so later on we're gonna of course parse that and send it already fixed from the exchange component to the balance component but now since we marked this we can just call the parse units on that as well to transform it into big number which format units accept so now it's loading pulls and everything is looking great we have two different balances below two different inputs and for now everything is entirely static but soon enough we're gonna focus on making all of it dynamic as you can see these components are not getting any inputs right now and they're just waiting for us to do something with them with that said before we focus on that we can finalize the bottom part of our unit swap two which are going to be the buttons to approve the transaction as well as to actually enable the swap so let's focus on them right away before we do that we're gonna need some help from the utility functions we imported at the top so let's first get a couple of states something like const is approving we always want to know are we currently approving or not and for that we can call the is operation pending and pass the approve as a string we can duplicate this and check are we currently swapping so based on these we'll be able to show different pieces of the UI and then in here we can change this to swap for now but these are just dummy values later on we'll have to provide the actual swap execute state and swap approve state so for now I'm just gonna write to do right here next to these two and finally working with success messages we can say const success message is equal to get success message but later on we'll have to provide some additional states to this so for now I'm gonna also say to do there and the same thing is gonna go for get failure message so failure message and also get failure message we're gonna work on providing the proper parameters to all these functions really soon but right now the most important thing is that we have some of these constants which we can use to conditionally render our buttons so right below our div right here we can create a new dynamic block of code we're gonna check if approved needed so this is something that we're gonna have to get soon we don't need to have access to it so for now I'm gonna simply leave it as a string and then we're gonna say and and not is swapping so not is swapping there we go in that case so if the approval is needed and we're not currently swapping then we can render out a button and that button is going to check are we currently approving so is approving if we are we're gonna render approving else we're gonna simply say approve now if we save this it's gonna break of course so let's see what's gonna happen with that we can go to our inspect element and then go to the console in here we can see that cannot read properties of undefined reading status so already just by calling these functions with wrong parameters we are getting some errors that means that we'll have to come in the mount for now while we actually get the right parameters to them and as you know I always like to guide you through all the errors that we go through usually it's not uncommon for people to simply skip that while creating tutorials I want to guide you to the real process of creating this application from scratch to finish with all the errors included because errors and bugs are normal parts of the development cycle great so now we can go down we have this button which is not yet styled so we cannot really see it so let's apply some style stood let's say class name is going to be dynamic so let's do something like this that's going to be a template string we can give it a styles that action button like this that's going to be one C right there and then if we save it it's going to already look better but now we can provide additional styles where later on we're going to have the can approve state based on that we can render different styles so if can approve is true we can render the bg-site-pink and then text-white and then else if we cannot approve we can render the bg-site-dim2 and then text-site-dim2 as well if we save this you can see that we have something that looks like a button right now now let's also give it a disabled property so disabled and it's going to be disabled if not can approve right here but this can approve again we don't have yet so I'm going to simply leave it as a string later on we're going to remove those string signs for now it's going to be always enabled and it's also going to have an on-click which for now is going to be set to an empty callback function this is our button for approving but now if the approval is not needed and if we're not swapping in that case we want to render a different button so for now let's simply copy this button and then instead of closing this block right here we can remove that and we can call a question mark which is eternity operator so now we're rendering this button if this is true if that is not true then we can for now copy that button and again make sure to close everything properly so we have to close that button right here and we have to close the eternity operator so one more time if approval is needed and we're not currently swapping then we're going to show the approval button else we're going to show the swap button of course it's not going to be the same as this one in here we can say if not can swap then it's going to be enabled for the class name we're going to check the can swap right here instead of can approve and the class names are going to be the same finally inside of there we're going to have some additional logic we can say if is swapping or just by using the eternity operator is swapping then we want to show swapping da da da else we want to check if has enough balance again for now we don't have that variable so we're going to put it in a string so if it has enough balance then we can simply say swap if it doesn't we're going to say insufficient balance there we go of course later on we'll have to remove those string signs from these properties right here to make that dynamic and finally we can focus on success or failure messages so right below the block of code with buttons we can open a new block of code and say if failure message and and no reset state then we want to show a p tag this p tag is going to have a class name equal to styles dot message but of course it has to be dynamic so styles dot message and we're going to render the failure message now if we have a success message so right below we can say colon if there is a success message in that case we can render another p tag which is going to be the same as this one class name message and we render the success message and else we're simply going to render an empty string now that's going to be it for now but as you can see we don't have access to any of these variables for now so we can simply leave them as strings later on we're going to modify them and for now we can simply see success message that means that everything in terms of UI is done and now we can focus on connecting our blockchain functionality with our existing front end application the last thing I would want to do is fix the styles for the button so right here you can notice the class name can approve is not really how it should because now we're giving it a couple of different strings we're giving it this part and then this part which are divided so it's only taking the classes from here and it's disregarding this what we have to do is wrap everything inside of a template string open up a new dynamic block of code like this then we can put the cannot prove inside of that block and then we can put this part as well just at the end after this block ends but still inside of the same template string so if we do this now as you can see we get the button styles and we can simply copy this class name down to our can swap as well and we can rename this to can swap there we go so now we are truly done with the UI of our exchange and now the fun part begins depends on who you ask maybe you were enjoying creating this layout but maybe some are going to enjoy hooking up this functionality from the blockchain there's going to be a lot of utility function calls there's going to be a lot of hook calls and a lot of work with those libraries that help us connect to the blockchain so let's get started let's start by grabbing the information from our metamask account right here at the top of our exchange component that's going to be const these structure the account and that's equal to use ethers that is a hook coming from the use dab core package then let's initialize a couple of different states so let's start typing the use state use this helper function right here and let's call it from value set from value and at the start that's going to be equal to a string of zero now let's create another use state that's going to be use state snippet and let's call it from token so which token do we want to exchange from and instead of leaving this blank we can use the pools zero and then dot token zero address to immediately render dot token the a in address has to be uppercase then we can proceed we can create another use state this one is going to be called to token right here set to token and that's going to be set to an empty string and then finally we're going to have another use state called reset state and set reset state which is at the start going to be set to false we're going to use this to reset the success message now we have this from value which is going to be a normal human readable string number so what do we do with that we have to transform it into a so-called big number so we can say const from value big number and that's going to be equal to parse units from value and we can say or or a string of zero so there always must exist something but I think since we are immediately resetting the value to zero that should be fine so we want to get the big number from the from value then we want to know a list of available tokens that we can swap from so let's say const available tokens and that's going to be equal to get available tokens and we pass in our liquidity pools then once we select some tokens we want to also get the counterpart tokens so to which tokens can we make a conversion too so we can call a get counterpart tokens function and we can pass the pools as well as the from token into it because we have to know from which token are we trying to make the exchange from and then finally we can also get the peer address so once we know from which token do we want to make an exchange from and to which token do we want to exchange to then we have to find a peer address of that specific liquidity pair so let's say find pool by tokens we're going to pass in our pools we're going to pass in our from token we're going to pass in our two token there we go and then we can say question mark dot and then we can get the address so question mark dot means that we only go to this point if this function actually returns something and this pair address has to be a value has to be a string so we can use this new JavaScript operator question mark question mark and say if this right here is now or undefined then rather use an empty string great so now we have a lot of different values we can work from but that is not the end now we have to get a lot of different contract addresses so let's start with const router contract is equal to new contract and then we pass in the router address which is coming from the config and we have to pass the abis dot router zero two i'm going to expand this just a bit so everything fits in one line then we have to get the const from token contract so we have to know from which contract are we transacting from so let's say new contract we pass in the from token and we also pass the ERC 20 dot a bi as the token follows the ERC 20 smart contract then let's talk about the const from token balance so we have to know the balance of our token and for that we can use the use token balance hook it accepts the from token as well as the account then we have to know the two token balance so that's going to be const two token balance that's going to be equal to use token balance we're going to pass the two token and we're going to pass the account now that we have the from token balance and two token balance there is a third thing we need const token allowance now if you think about it before I briefly mentioned that the swap is a two step process first we have to approve and then we can actually make a swap so let's get the use token allowance and we're going to pass in the from token we're going to pass in the account and we're going to pass in the router underscore address in case this value doesn't exist then we can simply call the parse units and send a string of zero now that we have our allowance we can create a new variable const approved needed you can also call it approval needed but since we already called it approved needed at the bottom let's take consistent that's going to be equal to from value big number dot gt as in greater than token allowance so right here what we're doing is we're checking if the from value is greater than the token allowance if it is that means that we need to get the approval to make the swap so our variable is going to let us know that then we're going to create another one const form value is greater than zero of course it has to be greater than zero right so we can say from value big number dot greater than parse units and then we're going to pass in a string of zero again we're just making sure that everything just works properly by having these custom checks for our form and then finally the last check is const has enough balance and we can check that by saying from value big number dot LTE lower than or equal to from token balance and then in case the from token balance doesn't exist we can again use that new JavaScript operator and then we can pass the parse units zero just to make sure we don't run into any errors later on great so now we have a lot of these different checks I would call them but now we are ready to actually start adding the functions they're going to allow us to send or approve transactions and for that we're going to use the use contract function coming from the use dab functionality that is the only one that we still haven't used so scrolling down we can say const we want to destructure two different things a state and also a send and that's going to be equal to use contract function like this we call it as any other hook but it will get a bit more complicated so the state we're going to rename to swap approve state and then the send we're going to rename to swap approve sent it is like a variable and then a function all working to make our approval successful of course to our hook use contract function will have to pass a couple of parameters the first one is from token contract then the second one is a string that's going to say approve and then the third one is an object where we can say transaction name is on approve requested and then we also can provide a gas limit buffer percentage and we can set it to something like 10% great so now we have a function which we can run our approve functionality now let's copy it duplicate below and we want to also make this work for the actual swap so let's say swap execute state again it is a two step process so execute and then swap execute send as well of course we have to change this to the router contract we're going to change the approve to swap exact tokens for tokens now you might be wondering what this is so let's google it one google search is immediately going to bring you to the router 0 to uniswap docs and then we can again control f to find that exact function in here you can see that we're using the built in uniswap functionalities because in our crank we built on top of uniswap so in here you can read more about what properties do you have to send in but essentially the swap execute send is going to work exactly as swap exact tokens for tokens and finally right here we can say swap exact tokens for tokens as well with that we don't have those two functions which we can call on button clicks finally we can get back to those checks that we started creating at a start so that's going to be const is approving is operation pending but now we know what are we wondering about we're wondering about d swap approve state which is coming from here the second one is going to be about the swap so that's going to be the swap execute state not send but state in this case then we're going to work with can approve const can we actually click the button can we approve it and that's going to depend on a couple of checks from above so let's put it like this we can approve if we're not currently approving and if the approval is needed so approved needed we can swap if not approved needed so approval is not needed and we're not currently swapping and form value is greater than zero and we have enough balance so now I hope you can see why did we create all of these fields these are checks to make sure that we can swap and can approve and now we can simply use these variables to make those checks in the code finally for the success message and the failure message we can help pass our parameters the first parameter is the swap approve state and then the second one is the swap execute state because we want to make sure that the approval and the execution went successfully and then for the failure it's going to be the exact same thing so we can pass the same parameters again it's the function that makes a difference we want to make sure that we pass through all of these two states successfully so now we have the success message and the failure message as well now that we have all the states and we have created the functions which we can call it's time to focus on creating the functionality the logic the actual verbs of our application the functions so let's say const on approve requested so this is going to be once we request the approval then we want to call the swap approve send we're going to pass in the router address and we're going to pass the ethers dot constants dot max integer 256 this is how it is written inside of the unit swap docs the second value is always going to be the maximum integer there is because we always want to approve for the maximum value so that once we approve for the first time we can then every other time simply swap without having to approve again and now finally we're going to focus on the most important thing which is the function for the swap so we can say const on swap requested we're going to call the swap execute send and remember we talked about this function it is the same one that I showed you before swap exact tokens for tokens so at the start right here we said hey make our swap execute send this specific function which is coming from unis swap so now we know which values we have to pass I'm even going to paste it right here at the top so that we know what is what and let's create it let's pass those parameters one by one the first one is the amount in so that's going to be from value big number then we have the amount out that's going to be zero then we have an array of addresses which are going to be from token and to token then we have our account to and then finally we have our deadline we can calculate that by setting the map that floor we can take the date that now divided by 1000 and then we can add 60 times 20 now of course you can put any deadline right here if I'm not mistaken this is going to be two minutes but of course feel free to play with this however you'd like to then this is an asynchronous function so we can call a dot then on it and then we simply want to set from value to be equal to a string of zero because we want to reset it once the swap has completed now let's create a special function to update this number at the top the input number so that's going to be const on from value change which is going to accept the value then we want to first trim it so let's say const trimmed value is equal to value dot trim we want to make sure that we can easily work with it and then we can have a tribe block and a catch block then if we have a trim value meaning if it is not empty then we can parse units and we can pass in the value and then we can also set the from value to be that value there we go in the catch we can simply leave a console dot log with the error for now great and finally we have to have just two more handlers for when we change those tokens the tokens in and the tokens out so let's create a new const on from token change we're going to get the value and then we simply want to set the from token to be equal to that value we can of course duplicate that and then this is going to be on to token change where we're going to set the to token value there we go and finally the last thing is the use effect that's going to handle the success and failure messages so let's create this use effect right there it's going to accept a callback function has use effects usually do we can pass in the failure message and the success message as dependencies in the dependency array we want to check if a failure message or a success message exists and then we want to call a set timeout so set timeout it accepts another callback function and there we want to call the set reset state we want to also reset the from value not token to a string of zero and then we also want to set the to token to an empty string so we're essentially resetting everything and then we can provide 5,000 milliseconds or five seconds right here and of course we have to set this to set time out like this it is a built-in function and of course we have to import the use effect from the top so right at the top import use effect from react great a lot of logic a lot of code it's it's been tough right it's not an easy application to build again it seems simple two inputs but keep in mind we're working with the blockchain with smart contracts everything is fully connected and all these pieces of the UI will soon enough become dynamic so we'll be fetching live balances live from tokens live two tokens live liquidity pools so now that we have everything we need let's go ahead and actually send it to those functions so amount in is going to have the value as from value it's going to have an on change on from value change it's going to have a currency value which is going to be equal to from token we need to know from which token are we changing and that's going to be currency with a you then we're going to have a non-select and that on select is going to be on from token change not on from value change we have a value for the input and then we have a select change then we're going to pass in all available currencies which are equal to available tokens and then we have to pass the variable are we currently swapping which is going to be equal to is swapping and has enough balance great that's going to be it for the amount in now for the balance we simply have to pass the balance of the in token or the from token so we can say token balance is equal to from token balance we can repeat the process for the second balance that is the two balance but you have to change it to two token balance so just like this now let's pass all of the props to the amount out that's going to be from token is equal to from token it's going to be two token is equal to two token we have to know how much do we want to transact so that's going to be the amount in equal to from value big number we're going to pass in the pair contract which is going to be equal to pair address we also want to pass in the currency value so to which token do we want to change the value to so that's going to be two token we want to pass an on select to change the two token which is going to be on to token change right here and it looks like we misspelled it at the top so let's find it there we go on token token change no this is on to token change hopefully you caught that and then finally we pass a list of all the currencies which are the counterpart tokens right currencies in the amount in are the available tokens from which we can swap and then the currencies in the amount out are the counterpart tokens which we can use to swap too hopefully that makes sense and hopefully now you understand the difference between the amount and the amount out although they're quite similar in the layout and the look they're quite different in terms of props they're getting almost every single prop is different finally now that we have those variables we no longer have to use these boring static strings so now we have the approved needed we have the can approve so we can use it as a variable we have the can approve here as well then going down we have the can swap we have the can swap here there we go we have the has enough balance as well so that's gonna be good and we have the failure message we have the reset state and also the same goes for all of these strings right there it's going to be actual values there we go hopefully now you can see why it was necessary to create all of these so-called checks right or states derived from other states because it makes things so much simpler when actually rendering things we can simply say can swap instead of saying not approval needed and is not swapping and is from value greater than zero and has enough balance imagine if you had to type this out every time where we used can swap it would be a mess even though it's only two times in this case but some other things are used much more often so in this case you're really learning how to write clean and scalable and reusable code great with that said we now have everything on our component since our hot reloading is not working now is the moment of truth we changed a lot of things so we have to reload the app and hopefully it works it seems to be working which is great of course these values are still static because we haven't gone into those components and changed things out I've also noticed that we didn't yet provide the on-click properties to those buttons so on the on-click of the approval we're going to pass in the on-approve requested which now we have on the swap we're going to pass the on swap requested and I think that's going to be it for now which means that we are ready to go and dive into the amount in to now take all of these props get them right here and then use them inside of that component so let's get started with bringing our amount in component to life let's get started by getting our props right into this component so first we have the value then we have the on-change and there's a couple more if you want to know which one these are you can simply copy them from here but in this case we can keep writing them right there so we have the value we have the on-change we have the currency value as well on select is another one currencies and then finally is swapping there we go now we have the show list already but we're going to need one more state so we can create a new used state snippet and that's going to be active currency so which one is currently selected and at the start it can be set to a string that says select then we're going to also have a ref so let's say const ref is equal to use ref there we go now in here we can also call the use on click outside hook where we're going to pass a ref to it and then a callback function that's going to set the show list to false and if I'm not mistaken these three lines are going to be repeated in the amount out so let's simply move there to the amount out and then right here we can just base them there there we go so now we have the currency we have the ref and we also have the use on click amount out great so let's get back to the amount in and let's focus on actually using all of these props we can start with the input values so first the value is not going to be an empty string it's going to be value disabled is going to be only if we are currently swapping then we want to disable the input then on the on change we always get an event and there we want to check if the type of on change is equal to a function because sometimes we're not going to have it because it's possible that we pass something else so if it is a function then we want to call the on change to which we can pass the e dot target value that's going to be it for the input then we have our div we have our button inside of that button we're going to pass the active currency because now we have it if we save that you can notice currently it is just select and then finally we have our UL to dot UL we're going to add a ref equal to ref and now is the time that we actually map over our real tokens so let's remove this empty array and let's do it like this object dot entries so we have a lot of different entries of objects and these are inside of currencies now that's going to give us both the key and the value for a specific token or a currency so we can map through them but we're going to be getting a list of arrays so instead of doing object destructuring and getting the token and the token name we have to do array destructuring using the square brackets like this now inside of there we're rendering an L i with a key and a class name and as we said later on we want to check if the active currency is equal to the currently selected token name so let's spell this properly and that is it now it's going to be dynamic as well we can reload the page to check the changes and believe it or not if you click select we get real values real tokens from our blockchain isn't that crazy remember we created those liquidity pools on our own so now we have jsn goal jsn silver and she by inu jsn as well as wrap ether it is possible that you have some different ones as well now let's fix the on click property because now we can't really select different ones so let's add an on click to our L i it's going to be a callback function and there we can say if typof on select is triple equal to function then we want to call the on select again really being careful of when do we try to call this to reduce the amount of errors that can potentially happen we can set the active currency to token name and we can set the show list to false because we actually want to change it now if we save that reload the page you can notice that if you select jsn gold it's actually going to be selected there we go it seems to be working perfectly for some reason the show list is not closing so if I click it it is still open and this set show list should actually turn it to false but that's fine for now we can click outside to actually close it great so this is mainly it for our input component there's just one more thing though and that's going to be a use effect so let's create a use effect right there and that use effect is going to have a callback function and a dependency array has use effects usually do we're going to recall the function whenever currencies change or the currency value changes in there we want to check if object dot keys from currencies so we're going to get the keys and then if they include the currency value that is currently selected if that is the case then we want to set the active currency to be equal to currencies and then currency value I know it is a bit tricky but bear with me if that is not the case we can add an else so let's properly open a new block of code right here and now add an else saying set active currency to select so we want to reset it to select so now if you reload the page you can notice that the wrap ether is the first selected one and we can swap between other ones as well great with that said that's mostly going to be it for the amount in but you can notice that the balance is still not reflecting the changes so now might be a good time to jump into the balance component and make it come to life as well to our balance component we're passing just one prop which is the token balance so let's destructured from here token balance and it is no longer going to be hard coded so for now the only thing we have to do is delete this hard coded value and everything is going to be done automatically so now you can see that we have 0.1 wrap ether now in your case this value is most likely going to be zero but nowhere is at all I'm going to show you how to get the actual balance for your wrapped ethereum what you have to do is go to the real uniswap application so that's going to be app dot uniswap dot org there you'll have to connect your wallet by clicking this button connect a metamask wallet that's looking good and now we want to exchange ether that is the girly ether that we have right there and then you can select wrapped ether so what we have to do is we have to turn ether into an ERC 20 wrapped ether to be able to make transaction switted and to be able to swap it to other tokens so let's say that we want to transact 0.1 ether to wrap ether now you can simply wrap it you'll have to confirm it so let's go ahead and do just that as you can see one transaction pending I've already done this before so now I should have 0.2 wrapped ether for you it should say 0.1 there we go wraps your point 1 ether to weth we can close out of this as you can notice the balance for me changed to 0.2 wrapped ether for you it should still say 0.1 but the most important thing is that it's actually fetching some data right here great with that said we can close out of the balance we can close the amount in and we can copy the props that we have to pass to the amount out by holding the alt key and then double clicking the prop names we can go into the amount out and now we can simply these structure them and then paste them right here of course let's also put them in one line right here and we can add commas in between that's looking good and we are ready to dive into the amount out component we already have the show list the active currency and the ref but the most important thing right here is to calculate what we're going to be getting for the amount of the input currency so to do that we have to import something from utles and that's going to be called use amounts out so that's going to be a hook that's going to calculate it so we can say const amount out is equal to use amounts out and we're going to pass the pair contract the amount in the from token and then the two token now this must not be undefined or null so we're going to use the question mark question mark operator and set that to zero just a number in case we don't have any other value great so now we know how much we are getting what we can do is we can also copy the use effect from the amount in that's going to be a simple use effect for selecting the active currency so let's copy it and let's paste it right here great the last thing we have to do is plug those real values in so first let's add the value that's going to be format units and then the amount out then let's change the eth to active currency right here let's add a ref to our ul equal to ref and now we have to do the same thing we've done in the amount in so we can copy that part as well where we mapped over our object entries so let's copy everything from the object that entries all the way to the start of this function and we can paste it right here there we go now we have everything we need the class name in this case is going to be static so the class name is simply going to be currency list item we don't have to change it it's going to look like this of course if we properly close it and we can even remove the template string as it is only one dynamic value now we have to add an on click and the on click is again quite similar to the one in the amount in so let's copy it and let's paste it right here if type of on select is equal to function then we're going to select the token we're going to set the active currency the token name and we're going to set the show list to false that is it so now if we save this and if we reload the page again because of that hot reload bug you're going to notice that we have 0.2 wrapped ether and if you go into our meta mask that's going to be a different amount because this is just regular ether and not wrapped ether but under assets you can see all of the other currencies so if we try changing jsm gold the balance automatically changes and now we can also see that we only created the pairs to exchange the gold to wrap ether or jsm silver so this is being dynamically fetched from the blockchain let's select silver and we also get the dynamic balance now let's try exchanging 100 jsm gold to silver as you can see 100 gold is going to be 500 silver now it is important to mention that the exchange rates are not always going to be the same uniswap works on the principle and demand so the more supply there is of a specific coin the less it's going to cost when transacted from other tokens since our pool is incredibly small we can see huge differences in the amounts we'll be getting so for example if we try doing something like 500 there we go you can see we get 832 but for 100 we get 500 so if we try playing with it for 500 we get 832 and then for 100 we get 500 so the value should be 5 times as much but it is only 1.5 times as much again the reason for that is that these are our own liquidity pools and we don't have many people providing values to those liquidity pools but this is exactly how the real uniswap works great so everything seems to be working perfectly now so let's go ahead and try to approve the transaction I'm going to click approve a new metamask notification is going to appear and it's going to say do you give permission to access your gsmg we indeed do give that permission keep in mind again this is a two step process but you only have to approve it once so now as you can see in the button it says approving again we know that because we created a lot of these different checks to know when we are approving and when we are not this process usually takes about 10 to 15 seconds so let's give it a few more moments and then once we are approved we can press swap that's going to open up a new metamask notification and you can see that we want to swap a specific amount so we can press confirm now you can see that the button says swapping and again this also takes about 10 to 15 seconds and there we go swap executed successfully and also all of the values have cleared so now if we were to check the balance it would be really hard to notice that we actually did exchange something as these values are huge but we are definitely missing some gsm gold and we have more gsm silver so this is working perfectly you can also try exchanging wrap ether silver shiba inu or anything like that to other currencies since we only added one pair for shiba inu inside of our liquidity pools we can only exchange it to wrap ether but that is fine that is exactly how we designed it so if you wanted to add more different combinations of different currencies for example being able to swap silver to something else other than gold in that case you can add those pairs inside of those liquidity pairs inside of crank hopefully that makes sense great with that said this is a phenomenal application we work through the amounts out amounts in and then most importantly worked a lot through the entire exchange component to get it all working it is using a lot of web three functionalities from contracts a b i's ERC 20 contracts and tokens to the use ether's functionalities we're also parsing the values getting the router address and a lot more utility helper functions everything is being dynamically pulled from different smart contracts and from the blockchain and we're also keeping track of a lot of different variables right there we have functions connected to blockchain that approve our swap and that execute our swap we have a lot of different checks to make sure that we are currently swapping or approving or something else we have proper air handling and messages and everything is working perfectly again might seem like a simple application but in my opinion it is the best application to properly learn how smart contracts blockchain and web three applications work behind the scenes we have only a couple of components but the logic to connect everything to connect these pools is tough you have to understand how all of this is working how we're getting pairs of different liquidity tokens but by now I'm sure your knowledge improved so much you might be overwhelmed at this moment because we were talking about pairs tokens contracts liquidity pools and a lot of different concepts but I'm sure now that you heard about it after some time it's all going to make so much sense so props to you for coming to the end of this phenomenal build this has definitely been one of the more interesting builds on the channel a complete web 3 uniswap 2.0 clone and as you already know on JavaScript mastery I always teach you how to deploy these applications as well so this one is not going to be different I'm going to teach you how to deploy your react application to the internet so that everybody can see it we can open up our terminal by going to view and then terminal we can stop it from running by pressing control C and then why let's clear the console we can open up the package that Jason to figure out the build command in this case it's going to be react dash app colon build so let's run mpm run react dash app colon build this is going to build an optimized production version of your application now while that is doing its thing let's open up a website called netlify netlify is a website that allows you to simply deploy your react applications so either create an account or simply log in once you're logged in go to your sites there you'll be able to scroll down and then you can simply drag and drop your site output folder right there while we're doing this looks like the build folder has been generated so let's go right here let's go to our react app and then right here you can see the build folder let's reveal in file explorer or on finder if you're on mac let's drag it here and then simply drag and drop the build folder right here in a couple of seconds your project should get deployed let's reload the page and there we go while we reloaded it it got finalized let's also go to the main settings options at its site name and let's do something like uniswap clone jsm of course feel free to call it however you want to let's save it and let's click this link to go to it and there we go we have a uniswap clone jsm uniswap 2.0 and now we can connect our wallet so let's click the connect wallet button a metamask notification is going to appear asking us if we want to connect the metamask wallet this time not with the local host but rather with a real deployed site so let's connect immediately we can see the balance in our metamask account and let's try changing 0.001 wrap ether to something like let's do shiba inu we can only get about 90 which is fine let's go ahead and approve the transaction there we go we have to do that for the first time we'll have to wait a couple of seconds there we go the approval was successful but it looks like the input got cleared so let's retie 0.001 and select shiba inu that's about 90 and let's swap there we go let's confirm and let's wait a couple of seconds right now we have 9996498 so these three digits should change this number should go to 5 so let's check that out and now if we again check shiba inu there we go 9996 and now we have 579 which means that the transaction went through so now your smart contracts are compiled and deployed to the internet or rather should I say to the ethereum blockchain and then the application itself at least the frontend is deployed to the internet as well so you can take this link shared with your friends potential employers showcase your web 3 development skills with that said huge thanks to crank not only for sponsoring this video but also for creating such an amazing software that allows us to build web 3 applications so simply and so intuitively with that said that's going to be the end of this great video thank you so much for watching and I'll see you in the next one have a wonderful day

---

## 03:15:31 - Deployment



---

